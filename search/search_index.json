{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Obsidian Notes","text":"<p>Publish your public notes with MkDocs</p>"},{"location":"#hello-world","title":"Hello World!","text":"<p>The <code>index.md</code> in the <code>/docs</code> folder is the homepage you see here.</p> <p>The folders in <code>/docs</code> appear as the main sections on the navigation bar.</p> <p>The notes appear as pages within these sections. For example, Note 1 in <code>Topic 1</code></p>"},{"location":"Features/LaTeX%20Math%20Support/","title":"LaTeX Math Support","text":"<p>LaTeX math is supported using MathJax.</p> <p>Inline math looks like \\(f(x) = x^2\\). The input for this is <code>$f(x) = x^2$</code>. Use <code>$...$</code>.</p> <p>For a block of math, use <code>$$...$$</code> on separate lines</p> <pre><code>$$\nF(x) = \\int^a_b \\frac{1}{2}x^4\n$$\n</code></pre> <p>gives </p> \\[ F(x) = \\int^a_b \\frac{1}{2}x^4 \\]"},{"location":"Features/Mermaid%20Diagrams/","title":"Mermaid diagrams","text":"<p>Here's the example from MkDocs Material documentation: </p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];\n</code></pre>"},{"location":"Features/Text%20Formatting/","title":"Text Formatting","text":"<p>You can have lists like this</p> <ul> <li>first</li> <li>second</li> <li>third</li> </ul> <p>Or checklist lists to</p> <ul> <li> Get</li> <li> things</li> <li> done</li> </ul> <p>Also, get highlights and strikethroughs as above (similar to Obsidian).</p> <p>More formatting options for your webpage here. (but not compatible with Obsidian)</p>"},{"location":"Topic%201/Note%201/","title":"Note 1","text":"<p>Example: link to Mermaid Diagrams under <code>Features</code></p>"},{"location":"Topic%201/Note%202/","title":"Note 2","text":""},{"location":"docker/00_TOC/","title":"00 TOC","text":"<ul> <li>introduccion</li> <li>\u00bfQu\u00e9 es?</li> <li>Instalaci\u00f3n</li> <li>Conceptos clave: im\u00e1genes, contenedores, vol\u00famenes, redes</li> <li>Gesti\u00f3n de im\u00e1genes</li> <li>Comandos b\u00e1sicos de Docker CLI para la gesti\u00f3n de im\u00e1genes y contenedores [2]</li> <li></li> <li>Creaci\u00f3n de im\u00e1genes personalizadas y registro en Docker Hub [1]</li> <li>Implementaci\u00f3n de una aplicaci\u00f3n en contenedor de Docker [1]</li> <li>Integraci\u00f3n de Docker con herramientas de orquestaci\u00f3n como Kubernetes o Docker Compose [3]</li> <li>Buenas pr\u00e1cticas y consideraciones de seguridad para el uso de Docker [3]</li> </ul> <p>Docker en python y django</p>"},{"location":"docker/01_que_es/","title":"\u00bfQu\u00e9 es Docker y para qu\u00e9 se utiliza? [1]","text":"<p>Docker\u00a0es una herramienta que puede empaquetar una aplicaci\u00f3n y sus dependencias en un contenedor virtual que se puede ejecutar en cualquier servidor Linux. Es muy flexible y portable, de manera que se puede desplegar en infraestructura f\u00edsica, nube privada, nube p\u00fablica, etc. Actualmente es soportado tambi\u00e9n por sistemas como Windows y macOS.</p> <p></p> <p>Arquitectura de una m\u00e1quina virtual</p> <p></p> <p>Arquitectura de un contenedor Docker, donde el kernel del anfitri\u00f3n es compartido</p> <p>Es virtualizaci\u00f3n a nivel de sistema operativo que, a diferencia de otros tipos como emulaci\u00f3n (VirtualBox), paravirtualizaci\u00f3n (Xen), o virtualizaci\u00f3n completa (VMWare, KVM), comparten el kernel o n\u00facleo del anfitri\u00f3n lo que lo hace m\u00e1s ligero.</p>"},{"location":"docker/02_instalacion/","title":"Instalaci\u00f3n de Docker","text":"<p>La documentaci\u00f3n oficial incluye instrucciones de instalaci\u00f3n de Docker Community para\u00a0MacOS,\u00a0Windows,\u00a0Linux\u00a0o servicios en la\u00a0nube.</p>"},{"location":"docker/02_instalacion/#instalacion-en-ubuntu","title":"Instalaci\u00f3n en Ubuntu","text":""},{"location":"docker/02_instalacion/#instalacion-en-arch","title":"Instalaci\u00f3n en Arch","text":""},{"location":"docker/02_instalacion/#instalacion-del-plugin-de-zsh","title":"Instalaci\u00f3n del plugin de ZSH","text":""},{"location":"docker/03_conceptos_clave/","title":"Conceptos clave","text":""},{"location":"docker/03_conceptos_clave/#imagenes","title":"Im\u00e1genes","text":""},{"location":"docker/03_conceptos_clave/#contenedores","title":"Contenedores","text":""},{"location":"docker/03_conceptos_clave/#volumenes","title":"Vol\u00famenes","text":""},{"location":"docker/03_conceptos_clave/#redes","title":"Redes","text":""},{"location":"docker/Docker%20en%20python%20y%20django/","title":"Docker en python y django","text":"<p>Ok, suficiente teor\u00eda. Empecemos a usar Docker y Django juntos. El primer paso es registrarse en Docker Hub para obtener una cuenta gratuita y luego instalar la aplicaci\u00f3n de escritorio Docker en nuestra m\u00e1quina local:</p> <ul> <li>Docker para Linux</li> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker</code></li> <li>Docker para Mac</li> <li>Docker para Windows</li> </ul> <p>Esta descarga puede tomarse alg\u00fan tiempo ya que es un archivo grande.</p> <p>Una vez que Docker se haya terminado de instalar, podemos confirmar que se est\u00e1 ejecutando la versi\u00f3n correcta escribiendo <code>docker --version</code> en la l\u00ednea de comandos. Debe ser al menos la versi\u00f3n 18.</p> <pre><code>$ docker --version\nDocker versi\u00f3n 19.03.5-ce, build 633a0ea838\n</code></pre> <p>Docker se utiliza a menudo con una herramienta adicional, Docker Compose, para ayudar a automatizar los comandos. Docker Compose se incluye con las descargas de Mac y Windows, pero si se est\u00e1 en Linux, tendr\u00e1 que a\u00f1adirse manualmente. Puede hacerse ejecutando el comando <code>sudo pip install docker-compose</code> despu\u00e9s de que la instalaci\u00f3n de Docker haya finalizado.</p> <ul> <li>Para distribuciones basadas en Arch ser\u00e1 algo tan f\u00e1cil como ejecutar <code>pacman -S docker-compose</code>. (Si surgen problemas con alg\u00fan fichero ya instalado en el sistema, borrar todos aquellos ficheros que est\u00e9n involucrados y proceder con la instalaci\u00f3n como se indica)</li> </ul>"},{"location":"docker/Docker%20en%20python%20y%20django/#docker-hola-mundo","title":"Docker, Hola Mundo","text":"<p>Docker se env\u00eda con su propia imagen de \"Hello, World\" que es un primer paso \u00fatil para comprobar la instalaci\u00f3n. Introducir en la l\u00ednea de comandos el comando <code>docker run hello-world</code>. Esto descargar\u00e1 una imagen Docker oficial y luego se ejecutar\u00e1 dentro de un contenedor. Se discutir\u00e1 sobre las im\u00e1genes y los contenedores en breve.</p> <pre><code>$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete\nDigest: sha256:b8ba256769a0ac28dd126d584e0a2011cd2877f3f76e093a7ae560f2a5301c00\nStatus: Downloaded newer image for hello-world:latest\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n(amd64)\n 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.\nTo try something more ambitious, you can run an Ubuntu container with:\n$ docker run -it ubuntu bash\nShare images, automate workflows, and more with a free Docker ID:\nhttps://hub.docker.com/\nFor more examples and ideas, visit:\nhttps://docs.docker.com/get-started/\n</code></pre> <p>El comando <code>docker info</code> nos permite inspeccionar Docker. Contendr\u00e1 una gran cantidad de informaci\u00f3n, pero si nos centramos en las l\u00edneas superiores tenemos 1 contenedor que se detenido y 1 imagen.</p> <pre><code>$ docker info\nClient:\n Debug Mode: false\n\nServer:\n Containers: 1\n  Running: 0\n  Paused: 0\n  Stopped: 1\n Images: 1\n...\n</code></pre>"},{"location":"docker/Docker%20en%20python%20y%20django/#django-hola-mundo","title":"Django, Hola mundo","text":"<p>Ahora vamos a crear un proyecto de Django \"Hello, World\" que se ejecuta localmente en nuestro ordenador y luego lo moveremos por completo dentro de Docker para que se pueda ver c\u00f3mo encajan todas las piezas.</p> <p>El primer paso es elegir una ubicaci\u00f3n para nuestro c\u00f3digo. Esto puede ser en cualquier parte del ordenador pero si est\u00e1s en Linux, una ubicaci\u00f3n f\u00e1cil de encontrar es el Escritorio . Desde la l\u00ednea de comandos navegamos hasta el <code>Escritorio</code> y creamos un directorio <code>code</code> para todos los ejemplos:</p> <pre><code>$ cd ~/Desktop\n$ mkdir code &amp;&amp; cd code\n</code></pre> <p>Luego creeamos un directorio <code>hello</code> donde  instalaremos Django usando Pipenv que crea un archivo Pipfile y un archivo Pipfile.lock.  Activamos el entorno virtual con el comando <code>shell</code>.</p> <pre><code>$ mkdir hello &amp;&amp; cd hello\npipenv install django==2.2.7\n$ pipenv shell\n(hello) $\n</code></pre> <p>Si se necesita ayuda para instalar Pipenv o Python 3, se pueden encontrar m\u00e1s detalles aqu\u00ed. Ahora podemos usar el comando <code>startproject</code> para crear un nuevo proyecto de Django llamado <code>hello_project</code>. A\u00f1adir un punto, <code>.</code>, al final del comando es un paso opcional pero muchos desarrolladores de Django lo hacen. Sin el punto, Django a\u00f1ade un directorio adicional al proyecto; con el <code>.</code>, esto no ocurre. Por \u00faltimo, utilice el comando <code>migrate</code> para inicializar la base de datos e iniciar la web local con el comando <code>runserver</code>.</p> <pre><code>(hola) $ django-admin startproject hello_project .\n(hola) $ python manage.py migrate\n(hola) $ python manage.py runserver\n</code></pre> <p>Suponiendo que todo ha funcionado correctamente, ahora deber\u00edamos poder navegar para ver el la p\u00e1gica de bienvenida de Django en http://127.0.0.1:8000/ en su navegador web.</p> <p></p>"},{"location":"docker/Docker%20en%20python%20y%20django/#pages-app","title":"Pages App","text":"<p>Ahora haremos una p\u00e1gina de inicio simple creando una <code>pages</code> app espec\u00edfica  para ello. Parar el servidor local escribiendo Control+c y luego usar el comando <code>startapp</code> a\u00f1adiendo el nombre de la <code>pages</code> que se desee.</p> <pre><code>(hola) $ python manage.py startapp pages\n</code></pre> <p>Django instala autom\u00e1ticamente un nuevo directorio de p\u00e1ginas y varios archivos para nosotros. Pero incluso aunque la app ha sido creada, nuestro <code>hello_project</code> no la reconocer\u00e1 hasta que la a\u00f1adamos a la configuraci\u00f3n de <code>INSTALLED_APPS</code> de archivo <code>hello_project/settings.py</code>.</p> <p>Django carga las apps de arriba a abajo, por lo que, en general, es una buena pr\u00e1ctica a\u00f1adir las nuevas aplicaciones debajo de las aplicaciones incorporadas en las que pueden confiar, tales como <code>admin</code>, <code>auth</code>, y todas las aplicaciones restantes.</p> <p>T\u00e9ngase en cuenta que si bien es posible simplemente escribir el nombre de la app, <code>pages</code>,  es mejor escribir la <code>pages.apps.apps.PagesConfig</code> completa lo que abre m\u00e1s posibilidades en la configuraci\u00f3n de las apps.</p> <pre><code># hello_project/settings.py\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'pages.apps.apps.PagesConfig', # nuevo\n]\n</code></pre> <p>Ahora podemos establecer la ruta URL para la app <code>pages</code>. Ya que queremos que nuestro mensaje aparezca en la p\u00e1gina de inicio usaremos la cadena vac\u00eda <code>''</code> . No olvidar a\u00f1adir la importaci\u00f3n de <code>include</code> en la segunda l\u00ednea tambi\u00e9n.</p> <pre><code># hello_project/urls.py\nfrom django.contrib import admin\nfrom django.urls import path, include # nuevo\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('pages.urls')), # nuevo\n]\n</code></pre> <p>En lugar de crear una plantilla en este punto, podemos simplemente codificar un mensaje en nuestra capa de la vista <code>pages/views.py</code> que producir\u00e1 la cadena <code>Hello, World!</code>.</p> <pre><code># pages/views.py\nfrom django.http import HttpResponse\n\ndef home_page_view(request):\n    return HttpResponse('Hello, World!')\n</code></pre> <p>\u00bfQu\u00e9 es lo siguiente? El \u00faltimo paso es crear un archivo <code>urls.py</code> dentro de la app <code>pages</code>y enlazarlo to <code>home_page_view</code>. Si se encuentra en un ordenador Mac o Linux, el comando <code>touch</code> se puede usar desde la l\u00ednea de comandos para crear nuevos archivos. En Windows habr\u00e1 que crear el nuevo archivo con un editor de texto.</p> <pre><code>(hola) $ touch pages/urls.py\n</code></pre> <p>En el editor de texto importar <code>path</code> en la primera l\u00ednea, a\u00f1adir la <code>home_page_view</code>, y colocar su ruta para otra vez ser la cadena vac\u00eda ''. N\u00f3tese que tambi\u00e9n provee un nombre opcional, <code>home</code>, para esta ruta lo cual es una buena pr\u00e1ctica.</p> <pre><code># pages/urls.py\nfrom django.urls import path\n\nfrom .views import home_page_view\n\n\nurlpatterns = [\npath('', home_page_view, name='home')\n]\n\n</code></pre> <p>El flujo completo de nuestra p\u00e1gina web Django es el siguiente:</p> <ul> <li>cuando un usuario va a su homepage ser\u00e1 primero encaminado a <code>hello_project/urls.py</code></li> <li>luego a <code>pages/urls.py</code></li> <li>y finalmente dirigido a la <code>home_page_view</code> que devuelve la cadena <code>Hello, World!</code></li> </ul> <p>El trabajo para una p\u00e1gina de inicio b\u00e1sica ha terminado. Iniciemos de nuevo el servidor local.</p> <pre><code>(hola) $ python manage.py runserver\n</code></pre> <p>Si se actualiza el navegador web en http://127.0.0.1:8000/, ahora saldr\u00e1 nuestro deseado mensaje.</p> <p></p> <p>Ahora es el momento de cambiar a Docker. Detengamos de nuevo el servidor local con Ctrl+C y salgamos de nuestro entorno virtual, que ya no necesitamos, escribiendo <code>exit</code>.</p> <pre><code>(hello) $ exit\n$\n</code></pre> <p>\u00bfC\u00f3mo sabemos que nuestro entorno virtual ya no est\u00e1 activo? No habr\u00e1 un par\u00e9ntesis alrededor del nombre de directorio en el prompt. Cualquier comando Django normal que se intente ejecutar en este punto fallar\u00e1. Por ejemplo, probar <code>python manage.py runserver</code> para ver lo que ocurre.</p> <pre><code>$ python manage.py runserver\nFile \"./manage.py\", line 14\n  ) from exc\n       ^\nSyntaxError: invalid syntax\n</code></pre> <p>Esto significa que estamos totalmente fuera del entorno virtual y preparados para Docker.</p>"},{"location":"docker/Docker%20en%20python%20y%20django/#imagenes-contenedores-y-el-docker-host","title":"Im\u00e1genes, Contenedores y el \"Docker Host\"","text":"<p>Una imagen Docker es una instant\u00e1nea en el tiempo de lo que contiene un proyecto. Est\u00e1 representado por un <code>Dockerfile</code> y es literalmente una lista de instrucciones que deben ser construidas/ejecutadas. Un contenedor Docker es una instancia en ejecuci\u00f3n de una imagen. Para continuar con la analog\u00eda de nuestro apartamento de antes, la imagen es el plano o conjunto de planos del apartamento; el contenedor es el edificio real totalmente construido.</p> <p>El tercer concepto central es el Docker host, que es el sistema operativo subyacente. Es posible tener varios contenedores ejecut\u00e1ndose dentro de un mismo Docker host. Cuando nos referimos a c\u00f3digo o procesos que se ejecutan en el Docker, significa que se ejecutan en el Docker host.</p> <p>Creemos nuestro primer <code>Dockerfile</code> para ver toda esta teor\u00eda en acci\u00f3n.</p> <pre><code>$ touch Dockerfile\n</code></pre> <p>Dentro del <code>Dockerfile</code> agregamos el siguiente c\u00f3digo que recorreremos l\u00ednea por l\u00ednea m\u00e1s abajo.</p> <pre><code># Pull base image\nFROM python:3.8\n\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n\n# Set work directory\nWORKDIR /code\n\n\n# Install dependencies\nCOPY Pipfile Pipfile.lock /code/\nRUN pip install pipenv &amp;&amp; pipenv install --system\n\n\n# Copy project\nCOPY . /code/\n</code></pre> <p>Los <code>Dockerfiles</code> se leen de arriba hacia abajo cuando se crea una imagen. La primera instrucci\u00f3n debe ser el comando <code>FROM</code> que nos permite importar una imagen base que usar, en nuestro caso Python 3.8.</p> <p>Luego usamos el comando <code>ENV</code> para establecer dos variables de entorno:</p> <ul> <li><code>PYTHONUNBUFFERED</code> asegura que la salida de nuestra consola se vea familiar y que no est\u00e9 almacenada en un b\u00fafer de Docker, lo cual no queremos</li> <li><code>PYTHONDONTWRITEBYTECODE</code> significa que Python no intentar\u00e1 escribir archivos <code>.pyc</code>, que tampoco deseamos</li> </ul> <p>A continuaci\u00f3n usamos <code>WORKDIR</code> para establecer una ruta de directorio de trabajo por defecto dentro de nuestra imagen llamada <code>code</code>que es donde guardaremos nuestro c\u00f3digo. Si no lo hicimos, entonces cada vez que queramos ejecutar comandos dentro de nuestro contenedor tendr\u00edamos que escribir una ruta muy larga. En su lugar, Docker asumir\u00e1 que queremos ejecutar todos los comandos desde este directorio.</p> <p>Para nuestras dependencias estamos usando <code>pipenv</code>, as\u00ed que copiamos tanto el archivo <code>Pipfile</code> como el archivo <code>Pipfile.lock</code> en el directorio <code>/code/</code> en Docker.</p> <p>Vale la pena tomarse un momento para explicar por qu\u00e9 <code>pipenv</code> crea un <code>Pipfile.lock</code>. El concepto de bloqueo de archivos no es exclusivo de Python o Pipenv; de hecho ya est\u00e1 presente en los gestores de paquetes de los lenguajes de programaci\u00f3n m\u00e1s modernos: <code>Gemfile.lock</code> en Ruby, <code>yarn.lock</code> en JavaScript, <code>composer.lock</code> en PHP, etc. Pipenv fue el primer proyecto popular en incorporarlos en la paqueter\u00eda de Python.</p> <p>La ventaja de un archivo de bloqueo es que esto conduce a una construcci\u00f3n determinista: no importa cu\u00e1ntas veces se instalen los paquetes de software, se obtendr\u00e1 el mismo resultado. Sin un fichero lock que \"bloquee\" las dependencias y su orden, no se cumplir\u00eda necesariamente. Lo que significa que dos miembros del equipo que instalan la misma lista de software pueden tener instalaciones de construcci\u00f3n ligeramente diferentes.</p> <p>Cuando estamos trabajando con Docker donde hay c\u00f3digo tanto local en nuestro ordenador como tambi\u00e9n dentro de Docker, el potencial de conflictos de <code>Pipfile.lock</code> surge cuando se actualizan paquetes de software.</p> <p>Siguiendo adelante usamos el comando <code>RUN</code> para instalar primero <code>pipenv</code> y luego <code>pipenv install</code> para instalar los paquetes de software listados en nuestro Pipfile.lock, actualmente s\u00f3lo Django. Es un es importante a\u00f1adir tambi\u00e9n el indicador <code>--system</code>, ya que por defecto Pipenv buscar\u00e1 el par\u00e1metro en el que instalar cualquier paquete, pero como estamos dentro de Docker ahora, t\u00e9cnicamente no hay ning\u00fan entorno virtual. En cierto modo, el contenedor Docker es nuestro entorno virtual y mucho m\u00e1s. As\u00ed que debemos usar la bandera <code>--system</code> para asegurarnos de que nuestros paquestes est\u00e1n disponibles en todo el Docker para nosotros.</p> <p>Como paso final copiamos el resto de nuestro c\u00f3digo local en el directorio <code>/code/</code> dentro de Docker. \u00bfPor qu\u00e9 copiamos el c\u00f3digo local dos veces, primero el Pipfile y Pipfile.lock y luego el resto? La raz\u00f3n es que las im\u00e1genes se crean en base a instrucciones de arriba hacia abajo por lo que queremos que las cosas que cambian a menudo -como nuestro c\u00f3digo local- sea el \u00faltimo. De esta manera s\u00f3lo tenemos que regenerar esa parte de la imagen ante un cambio y no se reinstala todo cada vez que lo haya. Como el software de los paquetes contenidos en nuestros <code>Pipfile</code> y <code>Pipfile.lock</code> cambian con poca frecuencia, implica que no tiene sentido copiarlos e instalarlos antes.</p> <p>Nuestras instrucciones de imagen ya est\u00e1n hechas, as\u00ed que vamos a construir la imagen usando el comando <code>docker build .</code>. El punto <code>.</code> indica que el directorio actual es donde se debe ejecutar el comando comando. Se genera una gran cantidad de texto en pantalla; s\u00f3lo se incluye las dos primeras l\u00edneas y las tres \u00faltimas.</p> <pre><code>$ docker build .\nSending build context to Docker daemon 154.1kB\nStep 1/7 : FROM python:3.8\n...\nStep 7/7 : COPY . /code/\n---&gt; a48b2acb1fcc\nSuccessfully built a48b2acb1fcc\n</code></pre> <p>Pasando a lo siguiente, ahora necesitamos crear un archivo <code>docker-composition.yml</code> para controlar c\u00f3mo ejecutar el comando que ser\u00e1 construido en base a nuestra imagen de <code>Dockerfile</code>.</p> <pre><code>$ touch docker-compose.yml\n</code></pre> <p>Contendr\u00e1 el siguiente c\u00f3digo</p> <pre><code>version: '3.7'\n\nservices:\n  web:\n    build: .\n    command: python /code/manage.py runserver 0.0.0.0:8000\n    volumes:\n      - .:/code\n    ports:\n      - 8000:8000\n</code></pre> <p>En la l\u00ednea superior se especifica la versi\u00f3n m\u00e1s reciente de Docker Compose que es actualmente 3.7  (no confundir con la versi\u00f3n de Python que puede ser bien parecida) A continuaci\u00f3n, especificamos qu\u00e9 <code>services</code> (o contenedores) queremos que funcionen en nuestro \"Docker host\". Es posible tener varios <code>services</code> funcionando, pero por ahora s\u00f3lo tenemos uno para el servidor <code>web</code>. Especificaremos c\u00f3mo construir el contenedor diciendo, \"Busca el directorio en curso <code>.</code> el <code>Dockerfile</code>\" . Luego, dentro del contenedor, ejecute el comando para arrancar el servidor local. El montaje de los vol\u00famenes sincroniza autom\u00e1ticamente el sistema de archivos Docker con nuestro sistema de archivos local. \u00a1Esto significa que no tenemos que reconstruir la imagen cada vez que cambiamos un solo fichero!.</p> <p>Por \u00faltimo especificamos los puertos (<code>ports</code>) a exponer dentro de Docker que solo ser\u00e1 el 8000, que es el puerto Django por defecto.</p> <p>Si es la primera vez que utiliza Docker, es muy probable que se est\u00e9 muy confundido en este momento. No hay motivo de preocupaci\u00f3n. Crearemos m\u00faltiples im\u00e1genes y contenedores Docker y, con la pr\u00e1ctica, el flujo comenzar\u00e1 a tener m\u00e1s sentido. Se ver\u00e1 como se usan archivos <code>Dockerfile</code> y <code>docker-composition.yml</code> muy similares en cada uno de los proyectos.</p> <p>El paso final es ejecutar nuestro contenedor Docker usando el comando <code>docker-compose up</code>. Este comando resultar\u00e1 en otro largo flujo de texto de salida en la l\u00ednea de comandos.</p> <pre><code>$ docker-compose up\nCreating network \"hello_default\" with the default driver\nBuilding web\nStep 1/7 : FROM python:3.8\n...\nCreating hello_web_1 ... done\nAttaching to hello_web_1\nweb_1 | Performing system checks...\nweb_1 |\nweb_1 | System check identified no issues (0 silenced).\nweb_1 | September 20, 2019 - 17:21:57\nweb_1 | Django version 2.2.5, using settings 'hello_project.settings'\nweb_1 | Starting development server at http://0.0.0.0:8000/\nweb_1 | Quit the server with CONTROL-C.\n</code></pre> <p>Para confirmar que realmente funcion\u00f3, volveremos a poner http://127.0.0.1:8000/ en el navegador web. Actualizaremos la p\u00e1gina y aparecer\u00e1 la p\u00e1gina \"Hello, World\".</p> <p>Django se est\u00e1 ejecutando ahora puramente dentro de un contenedor Docker. No estamos trabajando dentro de un entorno virtual local. No ejecutamos el comando <code>runserver</code>. Todo nuestro c\u00f3digo y nuestro servidor Django se est\u00e1 ejecutando desde dentro de un Docker aut\u00f3nomo. !Todo un \u00e9xito!</p> <p>Detendremos el contenedor con Ctrl+C y adem\u00e1s escribiremos <code>docker-compose down</code>. Los contenedores absorben una gran cantidad de memoria, as\u00ed que es una buena idea detenerlos de esta manera cuando hayamos terminado de usarlos.</p> <p>Los contenedores se han concebido para ser est\u00e1ticos (no pueden cambiar), por lo que utilizamos <code>volumes</code> para copiar nuestro c\u00f3digo en sitios donde si que pueda guardarse.</p> <pre><code>$ docker-compose down\nRemoving hello_web_1 ... done\nRemoving network hello_default\n</code></pre>"},{"location":"docker/capas/","title":"Capas","text":"<p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas. Para crear una imagen, generalmente se crea el archivo de texto <code>dockerfile</code> formado por diferentes instrucciones. Cada l\u00ednea representa una instrucci\u00f3n, y cada vez que se ejecuta el dockerfile se ejecutan dichas instrucciones de arriba a abajo. Estos <code>dockerfile</code>-s se almacenan como texto y se pueden compartir con facilidad, as\u00ed como almacenarse en sistemas de control de versiones. Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior. La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa. Cada imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados. Al final del <code>dockerfile</code>, la \u00faltima instrucci\u00f3n define el comando que se ejecutar\u00e1 cuando arranquemos el contenedor. Al ejecutar un comando a partir de la imagen creada, se ejecuta el comando especificado y se convierte en el proceso con PID 1 dentro del \u00e1rbol virtual de procesos. El contenedor seguir\u00e1 en marcha mientras el proceso creado siga en ejecuci\u00f3n.</p>"},{"location":"docker/contenedores/","title":"Contenedores","text":"<ul> <li>Un contenedor es una imagen instanciada (en ejecuci\u00f3n).</li> <li>Los contenedores no tienen un sistema operativo dentro sino que a\u00edslan el espacio de usuario.</li> <li>Son muy ligeros porque corren como un proceso sobre el SO del host.</li> <li>Los contenedores escalan en funci\u00f3n de la demanda, mientras que las M\u00e1quinas Virtuales (MV) tienen que ser aprovisionadas de recursos previamente. Una imagen de Docker es un archivo compuesto por m\u00faltiples capas que se utiliza para ejecutar c\u00f3digo en un contenedor de Docker. Estas im\u00e1genes son las plantillas base desde la que partimos ya sea para crear una nueva imagen o crear nuevos contenedores para ejecutar las aplicaciones</li> </ul>"},{"location":"docker/docker_hub/","title":"Docker hub","text":"<p>Docker Hub es el mayor repositorio del mundo de im\u00e1genes de contenedores con una gran variedad de fuentes de contenido, incluidos  desarrolladores, proyectos de c\u00f3digo abierto y proveedores de software independientes (ISV) que construyen y distribuyen su c\u00f3digo en contenedores. Los usuarios tienen acceso a repositorios p\u00fablicos gratuitos para almacenar y compartir im\u00e1genes o pueden elegir un plan de suscripci\u00f3n para repositorios privados.</p>"},{"location":"docker/gestion_imagenes/","title":"Gestion imagenes","text":"<p>Para crear una imagen de Docker, se sigue el siguiente proceso b\u00e1sico:</p> <ol> <li>Crear un archivo Dockerfile: El archivo Dockerfile es un archivo de texto que contiene las instrucciones para construir una imagen de Docker. En el archivo Dockerfile, se especifican el sistema operativo base, las dependencias, las bibliotecas y las configuraciones necesarias para la aplicaci\u00f3n.</li> <li>Escribir las instrucciones de Dockerfile: En el archivo Dockerfile, se incluyen las instrucciones para construir la imagen. Por ejemplo, se pueden utilizar las instrucciones <code>FROM</code> para especificar el sistema operativo base, <code>RUN</code> para instalar dependencias y bibliotecas, y <code>COPY</code> para copiar archivos de la aplicaci\u00f3n.</li> <li>Construir la imagen: Una vez que se ha creado el archivo Dockerfile, se puede construir la imagen utilizando el comando <code>docker build</code>. Este comando lee las instrucciones en el archivo Dockerfile y construye la imagen de Docker.</li> <li>Etiquetar la imagen: Despu\u00e9s de construir la imagen, se puede etiquetar con un nombre y una versi\u00f3n utilizando el comando <code>docker tag</code>.</li> <li>Subir la imagen a un registro de im\u00e1genes: Por \u00faltimo, se puede subir la imagen a un registro de im\u00e1genes de Docker, como Docker Hub, para que otras personas puedan descargarla y utilizarla para crear contenedores.</li> </ol> <p>Aqu\u00ed un ejemplo de archivo Dockerfile para construir una imagen de una aplicaci\u00f3n de Python:</p> <pre><code># Imagen base\nFROM python:3.9-alpine\n\n# Variables de entorno para configurar el entorno de la aplicaci\u00f3n\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n# Directorio de trabajo\nWORKDIR /app\n\n# Copiar los archivos de la aplicaci\u00f3n\nCOPY requirements.txt .\nCOPY . .\n\n# Instalar las dependencias\nRUN pip install --upgrade pip &amp;&amp; \\\n    pip install -r requirements.txt\n\n# Exponer el puerto 8000\nEXPOSE 8000\n\n# Comando para iniciar la aplicaci\u00f3n\nCMD [\"python\", \"app.py\"]\n</code></pre> <p>Este archivo Dockerfile se basa en la imagen de Python 3.9 Alpine y configura el entorno de la aplicaci\u00f3n. A continuaci\u00f3n, copia los archivos de la aplicaci\u00f3n y los requisitos en el directorio de trabajo y los instala. Finalmente, expone el puerto 8000 y utiliza el comando <code>python app.py</code> para iniciar la aplicaci\u00f3n.</p> <p>Para construir la imagen, se debe ejecutar el siguiente comando en la terminal, asegur\u00e1ndote de estar en la misma ubicaci\u00f3n que el archivo Dockerfile:</p> <pre><code>docker build -t nombre-de-la-imagen:version .\n</code></pre> <p>Despu\u00e9s de construir y etiquetar la imagen, se puede subir a un registro de im\u00e1genes de Docker utilizando el comando <code>docker push</code>. Por ejemplo:</p> <pre><code>docker push nombre-de-la-imagen:version\n</code></pre> <p>Una vez subida la imagen, se puede descargar y ejecutar en cualquier sistema que admita Docker utilizando el comando <code>docker run</code>.</p>"},{"location":"docker/imagenes/","title":"Im\u00e1genes","text":"<p>Una imagen de Docker es un paquete de software que contiene todo lo necesario para ejecutar una aplicaci\u00f3n, incluyendo el c\u00f3digo, las dependencias, el sistema operativo, las bibliotecas y las configuraciones.  Las im\u00e1genes de Docker se utilizan como plantillas para crear contenedores de Docker, que son instancias en tiempo de ejecuci\u00f3n de una imagen. Las im\u00e1genes se crean a partir de un archivo de configuraci\u00f3n llamado <code>dockerfile</code>, que especifica los componentes y configuraciones necesarios para la aplicaci\u00f3n. Una vez que se ha creado una imagen de Docker, se puede almacenar en un registro de im\u00e1genes de Docker, como Docker Hub o un registro privado, para que otros usuarios puedan descargarla y utilizarla en la creaci\u00f3n de contenedores. Las im\u00e1genes de Docker son portables y se pueden ejecutar en cualquier sistema que admita la plataforma Docker. Adem\u00e1s, como las im\u00e1genes est\u00e1n aisladas del sistema operativo del host, se pueden ejecutar varias instancias de la misma imagen en diferentes contenedores sin interferir entre s\u00ed.</p>"},{"location":"docker/imagenes/#_1","title":"Im\u00e1genes","text":""},{"location":"docker/instalacion_del_plugin_en_ZSH/","title":"instalacion del plugin en ZSH","text":"<p>La instalaci\u00f3n del plugin de Docker en Zsh puede variar dependiendo del m\u00e9todo que se utilice para instalar Zsh en tu sistema operativo. A continuaci\u00f3n, se describe el proceso de instalaci\u00f3n en sistemas operativos basados en Linux:</p> <ol> <li>Abre una terminal y aseg\u00farate de tener instalado Zsh en tu sistema y el gestor de paquetes Oh My Zsh. </li> <li>Ahora, abre el archivo de configuraci\u00f3n de Zsh en un editor de texto. Puedes hacerlo ejecutando el siguiente comando en la terminal:</li> </ol> <p><code>vim ~/.zshrc</code></p> <ol> <li>Busca la l\u00ednea que comienza con <code>plugins=</code> y agrega <code>docker</code> al final de la lista de plugins separados por espacios. Debe quedar algo como esto:</li> </ol> <p><code>plugins=(git docker)</code></p> <ol> <li> <p>Guarda los cambios y cierra el archivo.</p> </li> <li> <p>Ahora, reinicia Zsh para que los cambios tengan efecto:</p> </li> </ol> <p><code>source ~/.zshrc</code></p> <p>Una vez completados estos pasos, el plugin de Docker deber\u00eda estar instalado y listo para usarse en Zsh. Puedes probarlo ejecutando un comando de Docker en la terminal.</p>"},{"location":"docker/instalacion_del_plugin_en_ZSH/#otros-plugins","title":"Otros plugins","text":"<p>Aparte del plugin oficial de Docker, hay varios otros plugins que puedes instalar en Zsh para trabajar con Docker. Algunos de los plugins m\u00e1s populares son:</p> <ol> <li>zsh-autosuggestions-docker: Este plugin agrega sugerencias autom\u00e1ticas para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ol> <p><code>git clone https://github.com/hlissner/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</code></p> <ol> <li>zsh-completion-docker: Este plugin agrega completado de tabulaci\u00f3n para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ol> <p><code>git clone https://github.com/docker/cli.git ~/.oh-my-zsh/custom/plugins/zsh-completion-docker</code></p> <ol> <li>zsh-syntax-highlighting-docker: Este plugin agrega resaltado de sintaxis para comandos de Docker en Zsh. Puedes instalarlo utilizando el siguiente comando:</li> </ol> <p><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting-docker</code></p> <p>Para utilizar estos plugins, debes agregarlos a la lista de plugins en el archivo de configuraci\u00f3n de Zsh (<code>~/.zshrc</code>) de la misma manera que se agreg\u00f3 el plugin de Docker. Por ejemplo:</p> <pre><code>plugins=(git docker zsh-autosuggestions zsh-completion-docker zsh-syntax-highlighting-docker)\n</code></pre> <p>Igual que antes y una vez que hayas agregado estos plugins, reinicia Zsh para que los cambios tengan efecto. Luego, podr\u00e1s utilizar las funciones adicionales que ofrecen estos plugins para trabajar con Docker en Zsh.</p>"},{"location":"docker/introduccion/","title":"Introducci\u00f3n","text":"<p>La configuraci\u00f3n adecuada de un entorno de desarrollo local sigue siendo un gran reto a pesar de todos los otros avances de la programaci\u00f3n moderna. Simplemente hay demasiadas variables: diferentes ordenadores, sistemas operativos, versiones de lenguajes y frameworks, opciones de entornos virtuales,  y as\u00ed sucesivamente. Cuando se a\u00f1ade el reto de trabajar en equipo en un entorno en el que todos necesitan tener la misma configuraci\u00f3n, el problema se magnifica.</p> <p>En los \u00faltimos a\u00f1os ha surgido una soluci\u00f3n: Docker. Aunque s\u00f3lo tiene unos pocos a\u00f1os, Docker se ha convertido r\u00e1pidamente en la opci\u00f3n por defecto para muchos desarrolladores que trabajan en proyectos a nivel de producci\u00f3n.</p> <p>Con Docker finalmente es posible reproducir un entorno de producci\u00f3n de forma fiel y fiable localmente, desde la versi\u00f3n adecuada de Python hasta la instalaci\u00f3n de Django a la par de ejecutar servicios adicionales como una base de datos a nivel de producci\u00f3n. Esto significa que ya no es importante si se desarrolla en un equipo Linux, Mac o Windows. Todo funciona dentro del mismo Docker.</p> <p>Docker tambi\u00e9n facilita exponencialmente la colaboraci\u00f3n en equipo. Atr\u00e1s quedaron los d\u00edas de compartir archivos README largos y obsoletos para a\u00f1adir un nuevo desarrollador a un proyecto de grupo.</p> <p>En lugar de eso, con Docker s\u00f3lo se tienen que compartir dos archivos: <code>Dockerfile</code> y  <code>docker-compose.yml</code> y el desarrollador puede tener la confianza de que su entorno de desarrollo local es exactamente igual que el del resto del equipo.</p> <p>Docker no es una tecnolog\u00eda perfecta. Todav\u00eda es relativamente nueva y compleja bajo el cap\u00f3; a\u00fan est\u00e1 en desarrollo activo. Pero aspira a la promesa de una pol\u00edtica coherente y a un entorno de desarrollo compartible, que pueda ejecutarse localmente en cualquier ordenador o desplegado en cualquier servidor, lo que lo convierte en una opci\u00f3n s\u00f3lida.</p>"},{"location":"docker/introduccion/#que-es-docker","title":"\u00bfQu\u00e9 es Docker?","text":"<p>Docker es una forma de aislar todo un sistema operativo a trav\u00e9s de contenedores Linux que son un tipo de virtualizaci\u00f3n. La virtualizaci\u00f3n tiene sus ra\u00edces en los inicios de la inform\u00e1tica cuando las computadoras grandes y caras eran la norma. \u00bfC\u00f3mo podr\u00edan varios programadores utilizar la misma m\u00e1quina?. La respuesta fue la virtualizaci\u00f3n y espec\u00edficamente las m\u00e1quinas virtuales que son copias completas de un sistema inform\u00e1tico desde el sistema operativo en adelante.</p> <p>Cuando se alquila un espacio en un proveedor de cloud computing como Amazon Web Services (AWS) normalmente no se proporciona una pieza de hardware dedicada. En lugar de eso, se comparte un servidor f\u00edsico con otros clientes. Pero como cada cliente tiene su propio sistema virtual que se ejecuta en el servidor, le parece que tiene el suyo propio.</p> <p>Esta tecnolog\u00eda es la que hace posible a\u00f1adir o eliminar servidores de un servicio de cloud de forma r\u00e1pida y sencilla. Se trata en gran medida de software entre bastidores, no de hardware real.</p> <p>\u00bfCu\u00e1l es el inconveniente de una m\u00e1quina virtual? Tama\u00f1o y velocidad. Un sistema operativo hu\u00e9sped t\u00edpico (guest) puede ocupar f\u00e1cilmente hasta 700MB de tama\u00f1o. As\u00ed que si un servidor f\u00edsico soporta tres m\u00e1quinas virtuales, eso es al menos 2,1 GB de espacio en disco ocupado junto con el resto de necesidades para otros recursos como CPU y memoria.</p> <p>Al entrar en Docker, la idea clave es que la mayor\u00eda de los ordenadores dependen del mismo sistema operativo Linux. \u00bfY si virtualizamos desde la capa de Linux hacia arriba? \u00bfNo proporcionar\u00eda eso una forma m\u00e1s r\u00e1pida y ligera de duplicar gran parte de la misma funcionalidad? La respuesta es s\u00ed. Y en los \u00faltimos a\u00f1os los contenedores Linux se han vuelto muy populares. Para la mayor\u00eda de las aplicaciones -especialmente las aplicaciones web- una m\u00e1quina virtual proporciona mucho m\u00e1s recursos de los que se necesitan y un contenedor es m\u00e1s que suficiente.</p> <p>Esto, fundamentalmente, es Docker: \u00a1una forma de implementar contenedores Linux!</p> <p>Una analog\u00eda que podemos usar es la de los edificios y los apartamentos. Las m\u00e1quinas virtuales son como viviendas: edificios independientes con su propia infraestructura, incluida la fontaner\u00eda y calefacci\u00f3n, as\u00ed como cocina, ba\u00f1os, dormitorios, etc. Los contenedores Docker son como los apartamentos: comparten una infraestructura com\u00fan como la fontaner\u00eda y la calefacci\u00f3n, pero vienen en varios tama\u00f1os que se ajustan a las necesidades exactas de un propietario.</p>"},{"location":"docker/introduccion/#contenedores-vs-entornos-virtuales","title":"Contenedores vs. Entornos Virtuales","text":"<p>Como programador de Python, por ejemplo, se debe estar familiarizado con el concepto de entornos virtuales que son una forma de aislar los paquetes Python. Gracias al entorno virtual, una computadora puede ejecutar m\u00faltiples proyectos localmente. Por ejemplo, el Proyecto A podr\u00eda usar Python 3.4 y Django 1.11 entre otras dependencias; mientras que el Proyecto B usa Python 3.8 y Django 2.2. Configurando un entorno virtual dedicado en cada proyecto se puede gestionar estos diferentes paquetes de software sin contaminar nuestro entorno global.</p> <p>Hay una peque\u00f1a confusi\u00f3n derivada de que hay m\u00faltiples herramientas en este momento para implementar un entorno virtual: desde <code>virtualenv</code>, <code>venv</code> a <code>pipenv</code> o <code>poetry</code>, pero fundamentalmente todas hacen lo mismo.</p> <p>La mayor distinci\u00f3n entre los entornos virtuales y Docker es que los entornos virtuales s\u00f3lo pueden aislar paquetes Python. No pueden aislar a los no-Python como una base de datos PostgreSQL o MySQL. Y siguen dependiendo del sistema global; de la instalaci\u00f3n de Python a nivel de sistema (en otras palabras, de su ordenador). Los entornos virtuales apuntan a una instalaci\u00f3n Python existente; no contienen Python en s\u00ed mismos.</p> <p>Los contenedores Linux van un paso m\u00e1s all\u00e1 y a\u00edslan todo el sistema operativo, no s\u00f3lo las partes de Python. En otras palabras, instalaremos el propio Python dentro de Docker, as\u00ed como se instalar\u00e1 y ejecutar\u00e1 en \u00e9l la base de datos a nivel de producci\u00f3n.</p>"},{"location":"docker/redes/","title":"Redes","text":"<p>En Docker, las redes son una forma de conectar contenedores y permitir que se comuniquen entre s\u00ed y con otros servicios en la red. Las redes de Docker se utilizan para facilitar la comunicaci\u00f3n entre contenedores y para aislar los contenedores de otras redes. Docker proporciona varios tipos de redes, que se utilizan para diferentes prop\u00f3sitos: 1. Bridge network (red puente): Es la red predeterminada en Docker. Cada contenedor se conecta a una red puente virtual, que se encuentra en el host. Los contenedores en la misma red puente pueden comunicarse entre s\u00ed mediante sus nombres de host. 2. Host network (red de host): En esta red, los contenedores se conectan directamente a la red del host, en lugar de a una red virtual. Esto permite que los contenedores tengan acceso directo a los recursos de red del host, pero tambi\u00e9n puede presentar problemas de seguridad. 3. Overlay network (red de superposici\u00f3n): Esta red se utiliza para conectar contenedores que se ejecutan en diferentes hosts. Los contenedores en la misma red de superposici\u00f3n pueden comunicarse entre s\u00ed como si estuvieran en la misma red local. 4. Macvlan network (red de Macvlan): Esta red se utiliza para conectar contenedores directamente a una interfaz de red f\u00edsica del host. Esto permite que los contenedores tengan direcciones IP \u00fanicas y se comuniquen directamente con otros dispositivos en la red. Adem\u00e1s de estos tipos de redes, Docker tambi\u00e9n permite crear redes personalizadas para satisfacer las necesidades espec\u00edficas de una aplicaci\u00f3n o servicio.</p>"},{"location":"docker/volumenes/","title":"Vol\u00famenes","text":"<p>En Docker, un volumen es un mecanismo para persistir los datos que se generan dentro de un contenedor de Docker, de manera que puedan ser compartidos y reutilizados por otros contenedores. Un volumen de Docker es un \u00e1rea de almacenamiento de datos que se encuentra fuera del sistema de archivos del contenedor y que se mantiene separada del ciclo de vida del contenedor. Esto significa que los datos almacenados en un volumen persistir\u00e1n incluso despu\u00e9s de que se elimine el contenedor. Los vol\u00famenes de Docker se pueden utilizar para diferentes fines, como por ejemplo: - Compartir datos entre varios contenedores: Los vol\u00famenes permiten compartir datos entre varios contenedores de Docker, lo que facilita el intercambio de informaci\u00f3n entre diferentes aplicaciones y servicios. - Almacenar datos persistentes: Los vol\u00famenes se pueden utilizar para almacenar datos que deben persistir m\u00e1s all\u00e1 del ciclo de vida de un contenedor, como por ejemplo datos de una base de datos. - Hacer copias de seguridad de datos: Los vol\u00famenes permiten hacer copias de seguridad de los datos almacenados en un contenedor, lo que ayuda a proteger la informaci\u00f3n importante en caso de fallos en el sistema o errores humanos. En resumen, los vol\u00famenes de Docker son la forma de hacer persistentes los datos que se generan dentro de un contenedor de Docker y compartirlos con otros contenedores. Esto facilita el intercambio de informaci\u00f3n entre diferentes aplicaciones y servicios y permite almacenar datos persistentes y hacer copias de seguridad de los datos.</p>"},{"location":"docs/","title":"Sistemas Inform\u00e1ticos","text":""},{"location":"docs/#introduccion-a-los-sistemas-informaticos","title":"Introducci\u00f3n a los Sistemas Inform\u00e1ticos","text":""},{"location":"docs/#introduccion-a-los-sistemas-operativos","title":"Introducci\u00f3n a los Sistemas Operativos","text":""},{"location":"docs/#virtualizacion","title":"Virtualizaci\u00f3n","text":""},{"location":"docs/01_introduccion_sistemas_informaticos/","title":"Introducci\u00f3n a los Sistemas Inform\u00e1ticos","text":""},{"location":"docs/01_introduccion_sistemas_informaticos/#fundamentos-de-los-sistemas-informaticos-y-las-maquinas-virtuales","title":"FUNDAMENTOS DE LOS SISTEMAS INFORM\u00c1TICOS Y LAS M\u00c1QUINAS VIRTUALES","text":"<p>Objetivos: </p> <ul> <li>Aprender cu\u00e1les son y c\u00f3mo act\u00faan las unidades funcionales de un sistema inform\u00e1tico. </li> <li>Conocer las funciones de los principales componentes f\u00edsicos de un sistema inform\u00e1tico. </li> <li>Reconocer  los  componentes  f\u00edsicos  de  un  sistema  inform\u00e1tico  y  mecanismos  de interconexi\u00f3n. </li> <li>Verificar el proceso de puesta en marcha del equipo. </li> <li>Clasificar, instalar y configurar diferentes dispositivos perif\u00e9ricos. </li> <li>Conocer el concepto de m\u00e1quina virtual y sus ventajas- </li> <li>Operar  las  m\u00e1quinas  respetando  las  normas  de  seguridad  y  las  recomendaciones ergon\u00f3micas. </li> </ul> <p>Arquitectura de un sistema inform\u00e1tico. Modelos. </p> <p>Un sistema inform\u00e1tico es una m\u00e1quina que acepta unos datos de entrada, los procesa y genera unos resultados. En todo sistema inform\u00e1tico se distinguen dos partes claramente diferenciadas y necesarias: </p> <ul> <li>Hardware: conjunto de elementos f\u00edsicamente tangibles. </li> <li>Software:  parte  intangible  formada  por  instrucciones  o  datos  que  pueden  ser interpretados o procesados. </li> </ul> <p>Los sistemas inform\u00e1ticos actuales tienen como base las arquitecturas de  Von Neumann y Harvard. </p> <p>El modelo de Von Neumann consta de las siguientes partes: </p> <p>1 Unidad de procesamiento: se encarga de la ejecuci\u00f3n e interpretaci\u00f3n de instrucciones y datos formada por unidad aritm\u00e9tico l\u00f3gica (ALU), unidad de control y registros de almacenamiento. </p> <p>1) Memoria: almacena instrucciones y datos.  1) Dispositivos de entrada/salida: elementos que act\u00faan de interfaz con el resto de las partes. </p> <p></p> <p>En el modelo de Von Neumann las diferentes unidades funcionales se interconectan mediante buses de comunicaci\u00f3n o buses del sistema. Estos pueden ser: </p> <ul> <li>Buses de instrucciones: l\u00edneas de comunicaci\u00f3n que transmiten instrucciones. </li> <li>Buses de datos: l\u00edneas de comunicaci\u00f3n que transmiten \u00fanicamente datos. </li> <li>Buses de direcciones: l\u00edneas de comunicaci\u00f3n empleadas para acceder a las distintas memorias, indicando una direcci\u00f3n de acceso de lectura o escritura. </li> </ul> <p>En  el  modelo  Harvard  el  acceso  a  datos  e  instrucciones  se  realiza  simult\u00e1neamente  al encontrarse en caminos distintos. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#componentes-hardware-de-un-sistema-informatico","title":"Componentes hardware de un sistema inform\u00e1tico.","text":"<p>El hardware de un equipo consta de multitud de componentes, los m\u00e1s importantes son: el microprocesador,  la  placa  base,  la  memoria  principal,  los  dispositivos  de  almacenamiento secundario, la bater\u00eda o fuente de alimentaci\u00f3n y los perif\u00e9ricos. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#microprocesador","title":"Microprocesador","text":"<p>El microprocesador es un circuito integrado encapsulado de alt\u00edsimo nivel de integraci\u00f3n en los componentes que aloja. El microprocesador contiene una o m\u00e1s unidades centrales de proceso (CPU). Este es el centro neur\u00e1lgico de procesamiento del sistema. Las partes m\u00e1s importantes de una CPU son las siguientes: </p> <p>1) Unidad de control (UC): encargada del procesamiento, interpretaci\u00f3n y ejecuci\u00f3n de instrucciones y datos.  Env\u00eda al resto de componentes se\u00f1ales de control, estado o situaci\u00f3n para la correcta automatizaci\u00f3n de las diferentes funciones del sistema de manera sincronizada.  1) Unidad aritm\u00e9tico l\u00f3gica (UAL): componente encargado de realizar c\u00e1lculos aritm\u00e9ticos y l\u00f3gicos.  1) Registros: memorias temporales de poca capacidad y alta velocidad. </p> <p>Los microprocesadores actuales alojan la CPU, adem\u00e1s de otros muchos elementos. Los m\u00e1s importantes son: </p> <ul> <li>N\u00facleo: estructura que aloja las unidades funcionales de una CPU. En la actualidad, es com\u00fan que los micros contengan m\u00e1s de un n\u00facleo. Cada n\u00facleo es capaz de ejecutar una  instrucci\u00f3n,  sincroniz\u00e1ndose  con  el  resto  para  realizar  varias  tareas simult\u00e1neamente. </li> <li>Memorias cach\u00e9: memorias temporales, extremadamente r\u00e1pidas y cercanas al n\u00facleo. Atendiendo a su cercan\u00eda con este, suelen encontrarse tres niveles: </li> <li>L1 o de nivel 1: normalmente situada dentro de cada n\u00facleo. </li> <li>L2 o de nivel 2: suele estar situada fuera de los n\u00facleos, pero compartida entre varios. Act\u00faa de intermediaria de los niveles L1 y L3. </li> <li>L3 o de nivel 3: suele estar situada fuera de los n\u00facleos, pero compartida por todos ellos. Este nivel recibe o entrega instrucciones y datos a o desde los m\u00f3dulos de memoria. </li> <li>Controlador de memoria: la memoria RAM es gestionada por este componente. </li> <li>Controlador gr\u00e1fico: hace referencia a la capacidad de computaci\u00f3n de c\u00e1lculo para gr\u00e1ficos. No todos los procesadores integran esta caracter\u00edstica, puesto que las tarjetas gr\u00e1ficas dedicadas a este prop\u00f3sito poseen mayor rendimiento.</li> </ul> <p>En cuanto a las caracter\u00edsticas m\u00e1s importantes de los procesadores, destacan: </p> <ol> <li>Velocidad o frecuencia: medida en gigahercios (GHz), hace referencia al n\u00famero de ciclos que tienen que transcurrir para ejecutar una instrucci\u00f3n o parte de ella en cada CPU. A mayor frecuencia, mayor velocidad de procesamiento. </li> <li>N\u00famero  de  hilos:  los  procesadores  pueden  ejecutar,  al  mismo  tiempo,  hilos  de procesamiento, es decir, tareas como parte de un mismo proceso. Este concepto se refiere al n\u00famero de hilos con los que los n\u00facleos del procesador son capaces de trabajar en paralelo. </li> <li>Nivel de integraci\u00f3n: hace referencia a la medida de nan\u00f3metros (nm) empleados para la fabricaci\u00f3n del procesador, aplicando t\u00e9cnicas litogr\u00e1ficas. Cuanto menor sea esta cantidad, mayor nivel de integraci\u00f3n tendr\u00e1 al poder incluir en el mismo espacio mayor n\u00famero de componentes. </li> <li>Consumo: medido en watios (W), depende del voltaje e intensidad que necesite el procesador.  </li> <li>Potencia de disipaci\u00f3n t\u00e9rmica (TDP): hace referencia a watios t\u00e9rmicos, con objeto de buscar una soluci\u00f3n de refrigeraci\u00f3n al procesador. Los equipos m\u00f3viles se distinguen claramente por su bajo TDP. </li> </ol> <p>Link: \u00bfPor qu\u00e9 la relaci\u00f3n entre CPU, RAM y almacenamiento decide el rendimiento?</p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#memoria-principal","title":"Memoria principal","text":"<p>La memoria de almacenamiento principal se encuentra conectada a la CPU, a la cual abastece almacenando instrucciones o datos de forma temporal, es decir, cuando carece de energ\u00eda, su contenido desaparece. </p> <p>La memoria principal engloba varios tipos de memoria: registros, memoria cach\u00e9 y memoria RAM.  La memoria principal est\u00e1 constituida por: </p> <p>1) Registros: estructuras de almacenamiento pertenecientes al n\u00facleo de la CPU de muy poca capacidad, pero cuyo acceso y escritura es extremadamente r\u00e1pido. La mayor\u00eda se encuentran en la UC y la UAL. El tama\u00f1o de los registros define la arquitectura, siendo de 32 o 64 bits.</p> <p>2) Memoria cach\u00e9: memoria intermedia entre los registros y la memoria RAM, que se encuentra en los n\u00facleos o en el microprocesador. Cuanto mayor es su capacidad, mayor capacidad de c\u00f3mputo tendr\u00e1 el micro, ya que disminuir\u00e1n las veces que esta tenga  que  recargarse  accediendo  a  la  memoria  RAM  y  volcar  nuevos  datos  o instrucciones.  Suelen  existir  tres  niveles  (L1,  L2  y  L3),  donde  se  alojan  de  manera compartida o  separada  las  instrucciones y  los  datos.  Es  com\u00fan  que  se  encuentren separados en alg\u00fan nivel para aumentar la velocidad de procesamiento, normalmente en L2 y L1. </p> <p>4) Memoria  RAM:  memoria  externa  al  microprocesador  que  se  agrupa  en  forma  de m\u00f3dulos de memoria instalados en la placa base. Sus principales caracter\u00edsticas son: </p> <ol> <li>Capacidad: tama\u00f1o especificado en gigabytes (GB). </li> <li>Velocidad:  frecuencia  de  trabajo  interna  de  cada  m\u00f3dulo.  Se  mide  en gigahercios (GHz). </li> <li>Voltaje: tensi\u00f3n necesaria para su funcionamiento (V). </li> <li>Latencias: especifica los tiempos de acceso a los datos de los chips del m\u00f3dulo de memoria. Cuanto menor sean las latencias, m\u00e1s velocidad tendr\u00e1 el m\u00f3dulo en localizar y disponer de los datos. Se mide en ciclos de reloj. </li> <li>N\u00famero de canales de comunicaci\u00f3n con el procesador: el n\u00famero de canales entre la memoria y el procesador para transferir informaci\u00f3n simult\u00e1neamente. Los m\u00f3dulos deben estar desarrollados con tecnolog\u00eda multicanal. Para ello, es necesario emplear parejas o cuartetos de m\u00f3dulos, respectivamente. Esto har\u00e1 que se incremente la velocidad de transferencia al trabajar el procesador en paralelo con varios m\u00f3dulos. </li> <li>Tipo de m\u00f3dulo: los chips de memoria se encapsulan en m\u00f3dulos DIMM o SODIMM, seg\u00fan sean para equipos de sobremesa o port\u00e1tiles respectivamente. </li> <li>Tecnolog\u00eda: los m\u00f3dulos de memoria actuales emplean una tecnolog\u00eda de tipo SDRAM DDR4. Son memorias de acceso aleatorio din\u00e1mico (DRAM), empleando doble recarga en su versi\u00f3n 4 (DDR4). En la siguiente figura, la muesca situada entre los contactos met\u00e1licos, en la parte inferior de cada m\u00f3dulo, se encuentra en posiciones distintas para evitar errores en la colocaci\u00f3n de los m\u00f3dulos sobre los z\u00f3calos de memoria. Los m\u00f3dulos de memoria con tecnolog\u00eda SDRAM-DDR4 ofrecen mejoras con respecto a sus predecesoras SDRAM-DDR3: menos voltaje, mayor frecuencia, aumentan la densidad de los chips de memoria y presentan un mayor ahorro energ\u00e9tico. </li> </ol> <p></p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#placa-base","title":"Placa base","text":"<p>Tambi\u00e9n llamada motherboard. La placa base es el circuito impreso principal de todo sistema inform\u00e1tico, que conecta todos los componentes hardware directa o indirectamente. Se puede considerar la pieza fundamental (junto con la CPU), ya que determina la potencia de c\u00e1lculo o procesamiento, la capacidad de expansi\u00f3n, el almacenamiento, el tipo de alimentaci\u00f3n o el tipo de caja. </p> <p>Las placas base se rigen por los llamados factores de forma. Estos determinan entre otros aspectos, las medidas de la placa, la disposici\u00f3n y lugar donde se alojan sus componentes (z\u00f3calos, conectores, buses de expansi\u00f3n), la potencia\u2026 </p> <p>Los factores de forma m\u00e1s utilizados son: </p> <ul> <li>ATX. La disposici\u00f3n de sus componentes mejora la refrigeraci\u00f3n. Es el m\u00e1s utilizado actualmente.  Presenta  variantes  como  Micro-ATX  o  Mini-ATX,  que  reducen  las dimensiones de las placas base y est\u00e1n orientadas a equipos menos potentes, reducido consumo y escasa capacidad de expansi\u00f3n. </li> <li>Variantes ITX. Orientados a equipos de muy bajo consumo y reducidas dimensiones. Pr\u00e1cticamente  todos  sus  componentes  est\u00e1n  integrados  en  la  misma  placa  base, consiguiendo reducir las dimensiones, pero afectando a su capacidad de expansi\u00f3n.</li> </ul> <p>Los principales componentes de una placa base son: </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#chipset","title":"Chipset","text":"<p>Es  el  principal  circuito  integrado  y  encapsulado  (microchip)  en  la  placa  base,  que  resulta f\u00e1cilmente distinguible por su tama\u00f1o y localizaci\u00f3n. </p> <p></p> <p>Su labor es gestionar todos los componentes  de la placa base, dot\u00e1ndolos de sincronismo  a trav\u00e9s de diferentes buses. Por ello, directa  o indirectamente,  el  chipset  siempre  interviene en cualquier operaci\u00f3n. Tanto es  as\u00ed, que \u00e9ste determina el procesador que se  puede instalar en la placa base, la memoria  RAM, la cantidad de buses disponibles para  ranuras  de  expansi\u00f3n,  el  arranque  del  sistema,  la  cantidad  y  tipos  de  conectores  internos  y  externos,  la  capacidad  de  overclocking, etc. </p> <p>Las funciones del chipset son: </p> <ul> <li>Coordinar  la  asociaci\u00f3n  entre  los  componentes  de  gran  capacidad  de transferencia de informaci\u00f3n o procesamiento, como el procesador, la memoria, buses PCI Express de gr\u00e1ficos. </li> <li>Actuar  de  concentrador  de  componentes  de  entrada  y  salida,  as\u00ed como  de dispositivos de baja velocidad. </li> </ul> <p>En las placas base ATX, el chipset se sit\u00faa al sureste del z\u00f3calo del procesador y son f\u00e1cilmente distinguibles al ser chips grandes y disponer de un gran disipador. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#zocalo-del-microprocesador","title":"Z\u00f3calo del microprocesador","text":"<p>El socket o z\u00f3calo del micro es el lugar donde se inserta \u00e9ste. Existen principalmente dos tipos: </p> <ul> <li>ZIF  o  PGA  (Pin  Grid  Array):  consiste  en  una  estructura  de  pl\u00e1stico  con  peque\u00f1os agujeros, donde se insertan las patillas del microprocesador. Este se coloca en el socket sin ejercer presi\u00f3n, ya que dispone de una palanca para encajarlo sin fuerza. </li> </ul> <p></p> <ul> <li>LGA (Land Grid Array): dispone de una base con contactos que se comunican con la placa  base, sobre  la  que cierra  una estructura  de metal  con  forma  de ventana.  El procesador dispone de contactos y no patillas, por lo que establece la comunicaci\u00f3n por presi\u00f3n gracias a dicha estructura. La instalaci\u00f3n en este socket es sencilla, con mucho menos riesgo de da\u00f1ar el micro. Permite mayor cantidad de contactos. </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#ranuras-de-memoria-ram","title":"Ranuras de memoria RAM","text":"<p>Las ranuras de memoria son espacios destinados a alojar los m\u00f3dulos de memoria RAM. Actualmente, los  m\u00e1s utilizados son ranuras DIMM SDRAM-DDR4 con  288 pines. Todas las ranuras disponen de una marca  para  alinear  el  m\u00f3dulo  correctamente,  as\u00ed  como  contenedores laterales para aumentar la sujeci\u00f3n de  este a la placa base.   </p> <p>Las  placas  base  disponen  de  tecnolog\u00eda  de  doble,  triple  o  cu\u00e1druple  canal  (llamadas  Dual  Channel,  Triple  Channel  o  Quad  Channel).  As\u00ed,  se  consigue  acceder  a  varios  m\u00f3dulos  simult\u00e1neamente,  mejorando la velocidad de acceso a la memoria RAM  por  parte  del  procesador.  Ello  gracias  a  duplicar,  triplicar o cuadruplicar el canal de 64 bits del single  channel por defecto.  </p> <p>Las  placas  base  presentan  las  ranuras  de  memoria  RAM asociadas con colores (parejas, tr\u00edos o cuartetos)  para hacer uso de esta caracter\u00edstica.  </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#ranuras-de-expansion","title":"Ranuras de expansi\u00f3n","text":"<p>Son los m\u00f3dulos encargados de alojar las  tarjetas  de  expansi\u00f3n  para  ampliar  las  caracter\u00edsticas del equipo. Seg\u00fan el ancho  de  banda  y  la  velocidad  de  transmisi\u00f3n,  encontramos  varios  tipos  de  buses  de  expansi\u00f3n,  los  cuales  emplean  diferentes  ranuras.  El  bus  m\u00e1s  empleado  es  el  PCI  Express, o PCIe, que se implementa hasta  con 16 l\u00edneas (lanes) de datos. Cada l\u00ednea  dispone de un ancho de banda de 2GB/s en  su versi\u00f3n 4.0. Las ranuras de expansi\u00f3n PCI  Express m\u00e1s comunes seg\u00fan sus lanes y su  ancho de banda son:  </p> <ul> <li>PCIe x1 v4.0:2 GB/s </li> <li>PCIe x4 v4.0:16 GB/s </li> <li>PCIe x16 v4.0:32 GB/s </li> </ul> <p>Las distintas versiones de PCIe son compatibles entre s\u00ed. Se emplean para alojar tarjetas gr\u00e1ficas, tarjetas de sonido, dispositivos de almacenamiento secundario, tarjetas adaptadoras de red, etc. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#bios-basic-input-output-system","title":"BIOS (Basic Input Output System)","text":"<p>Tambi\u00e9n llamado ROM BIOS. Es un chip que se encuentra f\u00edsicamente visible en la placa base y se encarga de varias tareas: </p> <ul> <li>Comprobar el sistema y lanzar su arranque. </li> <li>Realizar funciones b\u00e1sicas de E/S con el sistema operativo funcionando. </li> <li>Configurar el equipo a trav\u00e9s de una aplicaci\u00f3n llamada BIOS Setup Utility. </li> </ul> <p>Muchas placas disponen de dos BIOS. En caso de que una se corrompa, la otra se activa, impidiendo que el equipo deje de funcionar. </p> <p>La BIOS tiene asociada una memoria RAM-CMOS que almacena de manera temporal los datos de la configuraci\u00f3n del sistema. Estos datos aparecen cuando accedemos al BIOS Setup Utility: fecha y hora del sistema, medios de arranque, perif\u00e9ricos, buses, overclocking, chipsets\u2026 </p> <p>Al ser la RAM-CMOS una memoria vol\u00e1til, la placa base tiene una pila que la alimenta e impide que desaparezca su configuraci\u00f3n. Si la pila pierde su carga, es necesario ajustar algunos de estos valores para que el sistema arranque correctamente. </p> <p>Las placas base tambi\u00e9n disponen de unos pines o botones para resetear la memoria RAM- CMOS, si se desea volver a ajustar la configuraci\u00f3n del sistema a la versi\u00f3n de f\u00e1brica.</p> <p> </p> <p>En la foto puede distinguirse:</p> <ul> <li> <p>La pila</p> </li> <li> <p>Sistema de doble BIOS (backup Bios y Main Bios) </p> </li> <li> <p>Pines de reseteo de la memoria </p> </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#conectores-internos","title":"Conectores internos","text":"<p>Algunos de los conectores m\u00e1s importantes son: </p> <ul> <li>Conector  SATA:  empleado  para  la  transferencia  de  datos  entre  el  chipset  y  los dispositivos de almacenamiento secundario. Es el conector que m\u00e1s se utiliza para conectar discos duros. Sustituy\u00f3 al antiguo IDE. </li> <li>Conector  M.2:  se  usa  especialmente  para  almacenamiento  (discos  duros  SSD)  o conectividad en equipos de reducidas dimensiones, aprovechando el espacio en la placa base. Trabaja con buses SATA o PCIe, empleando distintos conectores cada uno de ellos. </li> <li>Conectores de ventiladores: los ventiladores refrigeran el procesador, la caja o incluso algunos chipsets. </li> <li>Conectores USB: encargados de conectar, a trav\u00e9s de un cable, los conectores USB del frontal de la caja de los equipos. </li> </ul> <p></p> <ul> <li>Conectores del panel frontal: se suelen presentar por colores, detallando en la placa base la correspondencia de cada conector. Los m\u00e1s empleados son: </li> <li>Bot\u00f3n de encendido. </li> <li>Bot\u00f3n de reset. </li> <li>Led de encendido. </li> <li>Led de uso de disco duro. </li> <li>Conectores de alimentaci\u00f3n: nutren de energ\u00eda el\u00e9ctrica a la placa base y a todos sus componentes.  Es  habitual  encontrar  un  conector  de  20 o  24  pines  que  suministra alimentaci\u00f3n a la placa base, y otro de 4 u 8 pines que alimenta al procesador (se encuentra cerca). </li> </ul> <p></p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#conectores-externos","title":"Conectores externos","text":"<p>La conexi\u00f3n entre perif\u00e9ricos y el equipo se realiza a trav\u00e9s de conectores de comunicaci\u00f3n externos anclados al lateral oeste de la placa base. Estos conectores utilizan diferentes buses de comunicaci\u00f3n hacia el chipset. </p> <p>Los principales conectores externos son: </p> <ul> <li>eSATA: utilizado para conectar dispositivos de almacenamiento externo. </li> <li>Thunderbolt: para conectar perif\u00e9ricos de almacenamiento o para transmitir v\u00eddeo a perif\u00e9ricos. Emplea tecnolog\u00eda \u00f3ptica. </li> </ul> <p></p> <ul> <li>USB: conector empleado para conectar perif\u00e9ricos, rat\u00f3n, teclado, impresora, discos duros externos, smartphones\u2026 Existen varias versiones de este conector. </li> </ul> <p></p> <ul> <li>Conectores de v\u00eddeo: transmiten se\u00f1ales de v\u00eddeo a monitores. Los m\u00e1s empleados son D-SUB (VGA),  DVI, Displayport y  HDMI  (los  dos  \u00faltimos tambi\u00e9n  pueden  transmitir audio). </li> <li>Conector Ethernet LAN: llamado tambi\u00e9n RJ45, empleado para comunicarse por cable de par trenzado en una red. </li> <li>Conectores  de  audio  Jack  y  S/PDIF:  transmiten  sonido  anal\u00f3gico  y  digital respectivamente. </li> <li>Conectores PS/2: para conectar teclados y ratones. </li> </ul> <p></p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#dispositivos-de-almacenamiento-secundario","title":"Dispositivos de almacenamiento secundario","text":"<p>Se emplean  para  almacenar  informaci\u00f3n  de  manera  permanente.  Hay  que  distinguir  los dispositivos de los medios, ya que los primeros alojan a los segundos, los cuales contienen la informaci\u00f3n.  Pueden  estar  juntos  (discos  duros  mec\u00e1nicos)  o  separados  (tarjeta  Flash  SD necesita un lector de tarjetas SD para leer o escribir en ella). Los principales dispositivos o medios de almacenamiento no vol\u00e1til se clasifican en: </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#medios-de-almacenamiento-flash","title":"Medios de almacenamiento Flash","text":"<p>Casi todos estos tipos de medios emplean tecnolog\u00eda Flash NAND, haciendo referencia a las puertas l\u00f3gicas que almacenan los bits. Por ejemplo: </p> <ul> <li>Disco  duro  SSD  (Solid  State  Drive):  dispositivo  de  estado  s\u00f3lido,  llamado  as\u00ed  en contraposici\u00f3n a los discos duros magn\u00e9ticos que presentan partes m\u00f3viles. </li> <li>Tarjetas de memoria: aunque existe multitud de tipos y con distintas capacidades, las m\u00e1s utilizadas son las SD y CompactFlash, en sus diferentes formatos. Los dispositivos donde se utilizan suelen ser port\u00e1tiles, es decir, c\u00e1maras de fotos, m\u00f3viles, consolas\u2026 </li> </ul> <p></p> <p>Dispositivos de almacenamiento magn\u00e9tico </p> <ul> <li>Disco duro mec\u00e1nico: formado por un conjunto de discos de material r\u00edgido apilados sobre el mismo eje rotatorio. Cada disco consta de dos caras con pistas conc\u00e9ntricas en cada una, susceptibles de ser magnetizadas y alterar as\u00ed su estado, para almacenar ceros o unos. Entre cada cara se encuentran los cabezales de lectura y escritura que act\u00faan sobre las pistas. </li> </ul> <p></p> <ul> <li>Cintas: medio de almacenamiento formado por una banda de pl\u00e1stico flexible que contiene pistas aptas de ser magnetizadas y que se recoge sobre s\u00ed para distribuirlo o almacenarlo de forma segura. Estos medios de almacenamiento se utilizan en centros de  procesos  de  datos  como  formas  de  backup,  ya  que  son  econ\u00f3micas  y  de  gran capacidad de almacenamiento, aunque lentas. </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#medios-de-almacenamiento-optico","title":"Medios de almacenamiento \u00f3ptico","text":"<p>Los  m\u00e1s  comunes  son  CD  (Compact  Disk),  DVD  (Digital  Versatile  Disk)  y  Blu-ray.  Emplean diferente  tecnolog\u00eda  l\u00e1ser  para  grabar  o  leer  en  la  superficie  de  los  discos,  almacenando informaci\u00f3n en forma de crestas y surcos. La capacidad tambi\u00e9n es un aspecto importante entre ellos, ya que cada uno puede tener: </p> <ul> <li>CD: hasta 700 MB. </li> <li>DVD: hasta 17 GB. </li> <li>Blu-ray: hasta 128 GB. </li> </ul> <p>Para leer, grabar o regrabar informaci\u00f3n necesitan unidades \u00f3pticas h\u00e1biles a una determinada velocidad, representada por \u201cX\u201d. </p> <p>Est\u00e1n en decadencia debido al auge del almacenamiento en la nube, discos duros externos (muy compactos y portables) y almacenamiento Flash. </p> <p>Los medios de almacenamiento secundario m\u00e1s empleados en la peque\u00f1a y median empresa, son los medios Flash y discos duros mec\u00e1nicos. Las ventajas de cualquier dispositivo Flash son: menos consumo de energ\u00eda, m\u00e1s ligeros, gran velocidad en operaciones de lectura y escritura, y m\u00e1s resistentes, al no incorporar partes m\u00f3viles. </p> <p>Los dispositivos magn\u00e9ticos son todav\u00eda una buena soluci\u00f3n desde el punto de vista econ\u00f3mico y de backup. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#fuente-de-alimentacion","title":"Fuente de alimentaci\u00f3n","text":"<p>La  alimentaci\u00f3n  el\u00e9ctrica  en  cualquier  sistema  inform\u00e1tico  es  fundamental,  ya  que  de  \u00e9l dependen todos los componentes del equipo.  </p> <p>La fuente de alimentaci\u00f3n es la encargada de proporcionar energ\u00eda a la placa base, as\u00ed como a todos los elementos que la rodean. Tiene tres objetivos principalmente: </p> <ol> <li>Suministrar energ\u00eda a todos los componentes. </li> <li>Actuar de barrera o protecci\u00f3n ante alteraciones (ruidos o picos) de la red el\u00e9ctrica externa. </li> <li>Facilitar la extracci\u00f3n del flujo de aire caliente del sistema en equipos de sobremesa. </li> </ol> <p>La fuente de alimentaci\u00f3n transforma la tensi\u00f3n de entrada de 230 voltios a valores inferiores, rectifica la corriente alterna en continua, filtra la se\u00f1al y la estabiliza.</p> <p>En fuentes de alimentaci\u00f3n para placas ATX, los voltajes de salida son de 3,3 V, 5 V, 12 V y -12 V. Adem\u00e1s, seg\u00fan el componente a alimentar nos encontramos con distintos conectores y cables de alimentaci\u00f3n.</p> <p></p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#perifericos","title":"Perif\u00e9ricos","text":"<p>Son los dispositivos a trav\u00e9s de los cuales los usuarios interact\u00faan con el sistema inform\u00e1tico. Se clasifican en: </p> <ol> <li>Dispositivos de entrada: permiten introducir informaci\u00f3n al sistema (rat\u00f3n, teclado, micr\u00f3fono\u2026). </li> <li>Dispositivos de salida: \u00fanicamente ofrecen al usuario informaci\u00f3n (pantalla, impresora, altavoces\u2026). </li> <li>Dispositivos de entrada y salida: ambas tareas. (Pantalla t\u00e1ctil). Podemos encontrar: </li> <li>Dispositivos  de  almacenamiento:  permiten  almacenara  y  recuperar informaci\u00f3n (discos duros, DVD\u2026). </li> <li>Comunicaci\u00f3n: permiten la comunicaci\u00f3n entre ordenadores o elementos de interconexi\u00f3n de un sistema en red (tarjeta Ethernet o Wi-Fi). </li> </ol> <p>Los adaptadores permiten a los perif\u00e9ricos ser utilizados empleando otra conexi\u00f3n diferente a la  utilizada  por  el  sistema  inform\u00e1tico  al  que  se  van  a  asociar.  Pr\u00e1cticamente  todos  los conectores disponen de una gran variedad de adaptadores (por ejemplo, PS/2 a USB, USB-A a USB-C, HDMI/VGA a Displayport\u2026)</p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#normas-de-seguridad-y-prevencion-de-riesgos-laborales","title":"Normas de seguridad y prevenci\u00f3n de riesgos laborales","text":"<p>Debemos adoptar unas recomendaciones ergon\u00f3micas y de seguridad b\u00e1sicas de cara a prevenir o minimizar cualquier riesgo laboral. </p> <p>En Espa\u00f1a, la Ley 31/1995, de prevenci\u00f3n de riesgos laborales, establece la seguridad para el trabajador cuando realiza sus actividades laborales. Esta ley se\u00f1ala que \u201clos trabajadores tienen derecho a una protecci\u00f3n eficaz en materia de seguridad y salud en el trabajo\u201d. </p> <p>Tanto el empresario como el trabajador tienen una serie de derechos y obligaciones en materia de riesgos laborales. Algunos de los derechos son: informaci\u00f3n a los trabajadores, evaluaci\u00f3n de riesgos en el puesto de trabajo, formaci\u00f3n o planes de emergencia ante riesgos graves. Para prevenir los riesgos laborales se debe: </p> <ol> <li>Adoptar un plan de prevenci\u00f3n de riesgos laborales. </li> <li>Evaluar los riesgos. </li> <li>Planificar y ejecutar la actividad preventiva. </li> </ol> <p>En nuestro caso, destacamos las siguientes normas de seguridad y prevenci\u00f3n con respecto a los equipos con pantallas de visualizaci\u00f3n: </p> <p>1) Pantalla:     1. Los caracteres deben estar bien definidos y configurados de forma clara.     1. El usuario deber\u00e1 poder ajustar f\u00e1cilmente la luminosidad y el contraste entre los caracteres y el fondo de la pantalla, y adaptarlos f\u00e1cilmente al entorno.     1. La pantalla deber\u00e1 ser orientable e inclinable a voluntad, con facilidad para adaptarse a las necesidades del usuario.     1. La pantalla no deber\u00e1 tener reflejos ni reverberaciones que puedan molestar.  1) Teclado:     1. El teclado deber\u00e1 ser inclinable e independiente de la pantalla para permitir adoptar una postura c\u00f3moda que no provoque cansancio en los brazos o las manos.     1. Tendr\u00e1 que haber espacio suficiente delante del teclado para que el usuario pueda apoyar los brazos y las manos.  1) Mesa o superficie de trabajo:     1. Debe tener dimensiones suficientes y permitir una colocaci\u00f3n flexible de la pantalla, teclado, los documentos y el material accesorio.     1. El espacio debe ser suficiente para permitir a los usuarios una posici\u00f3n c\u00f3moda.  1) Asiento de trabajo:     1. Deber\u00e1 ser estable, regulable en altura, proporcionando al usuario libertad de movimiento y procur\u00e1ndole una postura confortable.  1) Entorno: </p> <ol> <li>Debe existir un espacio de dimensiones suficiente para adoptar cambios de postura y movimientos de trabajo. </li> <li>La iluminaci\u00f3n debe ser adecuada, evitando deslumbramientos y reflejos. </li> <li>El ruido no debe perturbar la atenci\u00f3n del trabajador. </li> <li>Las condiciones atmosf\u00e9ricas de temperatura y humedad deben ser adecuada para el desarrollo del trabajo. </li> </ol> <p></p> <p>Cuando nos sentamos para trabajar con un ordenador, es conveniente tomar una postura adecuada: regular la altura del asiento, la mesa, el apoyo lumbar y el respaldo, apoyar el antebrazo cuando escribimos con el teclado o manejamos el rat\u00f3n, regular la inclinaci\u00f3n y altura de la pantalla\u2026 </p> <p>Adem\u00e1s, al utilizar los dispositivos el\u00e9ctricos, debemos: </p> <ol> <li>Leer los manuales de instrucciones de uso de todos los componentes el\u00e9ctricos. </li> <li>Mantener los componentes el\u00e9ctricos en buen estado. </li> <li>Desconectar los componentes de la red el\u00e9ctrica cuando no vayan a ser utilizados. </li> <li>Disponer de una instalaci\u00f3n el\u00e9ctrica adecuada para nuestros sistemas y que permita evitar accidentes ante corrientes excesivas o derivaciones. </li> <li>Manejar  correctamente  y  con  los  medios  necesarios  los  dispositivos  sensitivos  a descargas el\u00e9ctricas. </li> <li>Evitar manipular los componentes con las manos mojadas o h\u00famedas. </li> <li>Cuando  se  acceda  al  interior  de  los  dispositivos  el\u00e9ctricos,  estos  deben  estar desconectados de la red el\u00e9ctrica. </li> <li>No desplazar equipos no portables cuando est\u00e1n en funcionamiento. </li> </ol> <p>RECOMENDACIONES: </p> <ul> <li>El teclado ha de estar situado como m\u00ednimo a 10 cm de distancia desde el borde de la mesa. </li> <li>El rat\u00f3n debe estar cerca del teclado. </li> <li>La pantalla debe estar a una distancia m\u00ednima de 40 cm. </li> <li>La silla debe permitir tener un apoyo completo lumbar y ser regulable. </li> <li>Mantener una postura erguida, con las rodillas a la altura de la pelvis y los brazos apoyados. </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#secuencia-de-montaje","title":"Secuencia de Montaje","text":""},{"location":"docs/01_introduccion_sistemas_informaticos/#apertura-de-la-caja","title":"Apertura de la caja","text":"<p>Los chasis de las computadoras se producen en diversos factores de forma. Los factores de forma hacen referencia al tama\u00f1o y a la forma del chasis. </p> <p>Existen diferentes m\u00e9todos para abrir los chasis. Para conocer c\u00f3mo abrir un chasis espec\u00edfico, consulte el manual del usuario o el sitio Web del fabricante. La mayor\u00eda de los chasis se abren de una de las siguientes formas: </p> <ul> <li>Se puede retirar la carcasa del chasis en una sola pieza. </li> <li>Se pueden retirar los paneles superiores y laterales del chasis. </li> <li>Es posible que deba retirar la parte superior del chasis antes de poder retirar las tapas laterales. </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#instalacion-de-la-fuente","title":"Instalaci\u00f3n de la fuente","text":"<p>Es posible que un t\u00e9cnico deba reemplazar o instalar la fuente de energ\u00eda. La mayor\u00eda de las fuentes de energ\u00eda se pueden colocar de una \u00fanica forma en el chasis de la computadora. En general, hay tres o cuatro tornillos que sujetan la fuente de energ\u00eda al chasis.  Las  fuentes  de  energ\u00eda  tienen  ventiladores  que  pueden  vibrar  y  aflojar  los tornillos que no est\u00e1n asegurados. Al instalar una fuente de energ\u00eda, aseg\u00farese de que se utilicen todos los tornillos y de que est\u00e9n ajustados correctamente. </p> <p>\u00c9stos son los pasos que se deben seguir para la instalaci\u00f3n de la fuente de energ\u00eda: </p> <ul> <li>Insertar la fuente de energ\u00eda en el chasis. </li> <li>Alinear los orificios de la fuente de energ\u00eda con los del chasis.  </li> <li>Asegurar la fuente de energ\u00eda en el chasis con los tornillos adecuados. </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#instalacion-de-la-placa-base","title":"Instalaci\u00f3n de la Placa base","text":"<p>Lo  primero  es  instalar  componentes  en  la  motherboard  y  despu\u00e9s  instalar  la motherboard en el chasis de la computadora. </p> <ol> <li>Instalaci\u00f3n de una CPU y ensamblado de un disipador de calor o ventilador. </li> </ol> <p>La CPU y el disipador de calor o ventilador se pueden instalar en la placa base antes de colocarla en el chasis de la computadora. </p> <p>La CPU y la placa son sensibles a las descargas electrost\u00e1ticas. Al manipular una CPU y una placa, aseg\u00farese de colocarlas sobre una alfombrilla antiest\u00e1tica con descarga a tierra. Al trabajar con estos componentes, debe usar una pulsera antiest\u00e1tica. </p> <p>PRECAUCI\u00d3N:  Al  manipular una  CPU,  no  toque  los  contactos  de  la  CPU  en ning\u00fan momento.  </p> <p>La CPU se sujeta al socket de la motherboard con un  dispositivo de sujeci\u00f3n. En la actualidad, los sockets de  la  CPU  son  de  tipo  LGA  (Land  Grid  Array,  los  m\u00e1s  modernos) en los que el propio socket incluye los pines  en vez de hacerlo la pastilla del microprocesador.   </p> <p>Se debe colocar pasta t\u00e9rmica en la superficie del micro que ir\u00e1 en contacto con el disipador para facilitar su funci\u00f3n.  </p> <p>Cuando instale una CPU usada, limpie la CPU y la base del disipador de calor con alcohol isoprop\u00edlico. De esta forma, eliminar\u00e1 todos los restos del compuesto t\u00e9rmico anterior. Una  vez  que  las  superficies  est\u00e9n  listas  para  la  aplicaci\u00f3n  de  una  nueva  capa  de compuesto  t\u00e9rmico,  siga  las  instrucciones  del  fabricante  sobre  la  aplicaci\u00f3n  del compuesto t\u00e9rmico. </p> <p>El  disipador  de  calor  remueve  el  calor de  la  CPU.  El  ventilador  mueve  el  calor  del disipador hacia el exterior. </p> <p>Siga  estas  instrucciones  para  instalar  la  CPU  y  ensamblar  el  disipador  de  calor  o ventilador: </p> <p>1) Alinee la CPU de modo que el indicador de la Conexi\u00f3n 1 coincida con el Pin 1 del socket de la CPU. De esta forma, garantizar\u00e1 que las muescas de orientaci\u00f3n de la CPU est\u00e9n alineadas con las flechas de orientaci\u00f3n del socket de la CPU.  1) Conecte suavemente la CPU en el socket.  1) Cierre la placa de carga de la CPU y f\u00edjela. Para ello, cierre la palanca de carga y mu\u00e9vala por debajo de la pesta\u00f1a de retenci\u00f3n de la palanca.  1) Aplique una peque\u00f1a cantidad de compuesto t\u00e9rmico a la CPU y distrib\u00fayalo de forma pareja. Siga las instrucciones de aplicaci\u00f3n del fabricante. 1) Alinee los dispositivos de retenci\u00f3n del ensamblado del disipador de calor o ventilador con los orificios de la placa base.  1) Coloque el ensamblaje del disipador de calor o ventilador en el socket de la CPU. Tenga cuidado para no apretar los cables del ventilador de la CPU.  1) Ajuste  los dispositivos  de  retenci\u00f3n  del  ensamblaje del  disipador  de  calor o ventilador para mantenerlo en su lugar.  2. Instalaci\u00f3n de la memoria </p> <p>Colocar  la  memoria  RAM  en  la  motherboard  antes  de  colocarla  en  el  chasis  de  la computadora.  Antes  de  instalar  un  m\u00f3dulo  de  memoria,  consulte  el  manual  de  la motherboard o el sitio Web del fabricante para asegurarse de que la memoria RAM sea compatible.  </p> <p>Para instalar la memoria RAM, siga estos pasos: </p> <p>1) Alinee las muescas del m\u00f3dulo de  memoria RAM con las flechas de la  ranura y presione la memoria RAM  hasta  que  las  pesta\u00f1as  laterales  est\u00e9n en su lugar.    2) Aseg\u00farese  de  que  las  pesta\u00f1as  laterales traben en el m\u00f3dulo RAM.  Haga  una  inspecci\u00f3n  visual  para  determinar  la  existencia  de  contactos expuestos.  3) Para  montar  la  motherboard  y  evitar que  entre en  contacto  con las  piezas  met\u00e1licas  del  chasis,  se  utilizan soportes  de  pl\u00e1stico  o metal.  Solamente  se deben  colocar  los  soportes  que coincidan  con  los  orificios  de  la  motherboard.  La  instalaci\u00f3n  de  soportes adicionales puede impedir que la motherboard quede colocada correctamente en el chasis.  3. Instalaci\u00f3n de la motherboard Siga los siguientes pasos:  1) Instale los soportes en el chasis de la computadora. 1) Alinee los conectores de E/S de la parte trasera de la motherboard con las aberturas de la parte trasera del chasis. 1) Alinee los orificios para tornillos de la motherboard con los soportes. 1) Coloque todos los tornillos de la motherboard.  1) Ajuste todos los tornillos de la motherboard.  4. Instalaci\u00f3n de Unidades externas </p> <p>Las unidades que se instalan en los compartimientos internos se denominan unidades internas. Una unidad de disco duro (HDD, hard disk drive) constituye un ejemplo de una unidad interna. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#instalacion-de-un-disco-duro","title":"Instalaci\u00f3n de un Disco Duro","text":"<p>1) Coloque la HDD de modo que quede alineada con el compartimiento de la unidad de 3,5 in.  1) Inserte la HDD en el compartimiento de la unidad de modo que los orificios para tornillos de la unidad coincidan con los del chasis.  1) Asegure la HDD en el chasis con los tornillos adecuados. </p> <p>Una unidad \u00f3ptica es un dispositivo de almacenamiento que lee y escribe informaci\u00f3n en CD y DVD. El conector de alimentaci\u00f3n Molex suministra energ\u00eda a la unidad \u00f3ptica desde la fuente de energ\u00eda. El cable PATA conecta la unidad \u00f3ptica a la motherboard. </p> <ul> <li>Para instalar la unidad \u00f3ptica, siga estos pasos:</li> <li>Coloque la unidad \u00f3ptica de modo que quede alineada con el compartimiento de la unidad de 5,25 in. </li> <li>Inserte la unidad \u00f3ptica en el compartimiento de la unidad de modo que los orificios para tornillos de la unidad \u00f3ptica coincidan con los del chasis. </li> <li>Asegure la unidad \u00f3ptica en el chasis con los tornillos adecuados. </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#instalacion-de-tarjetas","title":"Instalaci\u00f3n de Tarjetas","text":""},{"location":"docs/01_introduccion_sistemas_informaticos/#tarjeta-de-red","title":"Tarjeta de red","text":""},{"location":"docs/01_introduccion_sistemas_informaticos/#_1","title":"Introducci\u00f3n a los Sistemas Inform\u00e1ticos","text":"<p>La tarjeta de red o NIC (Network Interface Controller) permite que la computadora se conecte a  una red. Utiliza ranuras de expansi\u00f3n PCI y PCIe  en la motherboard. </p> <p>Para instalar la NIC, siga los siguientes pasos:</p> <ul> <li>Alinee la NIC con la ranura de expansi\u00f3n  correspondiente de la motherboard.</li> <li>Presione suavemente la NIC hasta que la tarjeta quede colocada correctamente.</li> <li>Asegure la consola de montaje de la NIC para PC en el chasis con el tornillo adecuado. </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#tarjeta-de-video","title":"Tarjeta de video","text":"<p>Una tarjeta adaptadora de v\u00eddeo es la interfaz entre una computadora y un monitor. Una  tarjeta  adaptadora  de  v\u00eddeo  actualizada  proporciona una mayor  resoluci\u00f3n  de gr\u00e1ficos para juegos y programas de presentaci\u00f3n. Las tarjetas adaptadoras de v\u00eddeo utilizan ranuras de expansi\u00f3n PCI, AGP y PCIe en la motherboard.</p> <p>Para instalar la tarjeta adaptadora de v\u00eddeo, siga estos pasos:</p> <p>1) Alinee  la  tarjeta  adaptadora  de  v\u00eddeo  con  la  ranura  de  expansi\u00f3n correspondiente de la motherboard.  1) Presione suavemente la tarjeta adaptadora de v\u00eddeo hasta que la tarjeta quede colocada correctamente. 1) Asegure la consola de montaje para PC de la tarjeta adaptadora de v\u00eddeo en el chasis con el tornillo adecuado. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#cables-internos-conexiones-de-alimentacion-de-la-motherboard","title":"Cables internos: conexiones de alimentaci\u00f3n de la motherboard.","text":"<p>Al  igual  que  otros  componentes,  las  motherboards  necesitan  electricidad  para funcionar.  El  conector  de  alimentaci\u00f3n  de  tecnolog\u00eda  avanzada  extendida  (ATX, Advanced Technology Extended) tiene 20 o 24 pines. Adem\u00e1s, la fuente de energ\u00eda puede tener un conector de alimentaci\u00f3n auxiliar (AUX) de 4 o 6 pines que se conecta a la motherboard.</p> <p>Para instalar el cable de alimentaci\u00f3n de la motherboard, siga estos pasos:</p> <ul> <li>Alinee el conector de alimentaci\u00f3n ATX de 20 pines con el socket de la motherboard.  Presione suavemente el conector hasta que el clip est\u00e9 en su lugar. </li> <li>Alinee el conector de alimentaci\u00f3n AUX de 4 pines con el socket de la motherboard.  Presione suavemente el conector hasta que el clip est\u00e9 en su lugar.</li> </ul> <p>Para instalar el cable de alimentaci\u00f3n del micro</p> <ul> <li>Alinee el conector de alimentaci\u00f3n de 4 pines con el socket.  Presione suavemente el conector hasta que el clip est\u00e9 en su lugar.</li> </ul> <p>Para instalar el cable de alimentaci\u00f3n del ventilador del micro.</p> <ul> <li>Alinee el conector de alimentaci\u00f3n del ventilador (normalmente de 3 pines).  Ins\u00e9rtelo en su lugar.</li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#conectores-de-alimentacion-sata","title":"Conectores de alimentaci\u00f3n SATA","text":"<p>Los conectores de alimentaci\u00f3n SATA utilizan un conector de 15 pines. Los conectores de alimentaci\u00f3n SATA se utilizan para conectarse a discos duros, unidades \u00f3pticas o cualquier dispositivo que tenga un socket de alimentaci\u00f3n SATA.</p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#conectores-de-alimentacion-molex","title":"Conectores de alimentaci\u00f3n Molex","text":"<p>Los discos duros y las unidades \u00f3pticas que no tienen sockets de alimentaci\u00f3n SATA utilizan conector de alimentaci\u00f3n Molex.</p> <p>PRECAUCI\u00d3N: No utilice un conector Molex y un conector de alimentaci\u00f3n SATA en la misma unidad al mismo tiempo.</p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#conectores-de-alimentacion-berg","title":"Conectores de alimentaci\u00f3n Berg","text":"<p>Tiene 4 pines y suministran electricidad a las unidades de disquete.</p> <p>Instalaci\u00f3n de conectores de alimentaci\u00f3n</p> <ul> <li> <p>Conecte el conector de alimentaci\u00f3n SATA a la HDD.</p> </li> <li> <p>Conecte el conector de alimentaci\u00f3n Molex a la unidad \u00f3ptica.  Conecte el conector de alimentaci\u00f3n Berg de 4 pines a la FDD.</p> </li> <li> <p>Conecte los cables adicionales del chasis a los conectores correcpondientes, seg\u00fan las instrucciones del manual de la motherboard (ventiladores de caja, alimentaci\u00f3n de tarjeta gr\u00e1fica...).</p> </li> </ul>"},{"location":"docs/01_introduccion_sistemas_informaticos/#cables-datos","title":"Cables datos","text":""},{"location":"docs/01_introduccion_sistemas_informaticos/#cables-de-datos-pata-ide","title":"Cables de datos PATA (IDE)","text":"<p>A menudo, el cable PATA se denomina cable plano debido a que es ancho y plano. Adem\u00e1s, el cable PATA puede tener 40 u 80 conductores. Generalmente, un cable PATA tiene tres conectores de 40 pines. En el extremo del cable, hay un conector que se conecta a la motherboard. Los otros dos conectores se conectan a las unidades. Si se instalan varios discos duros, la unidad principal se conectar\u00e1 al conector del extremo del cable. La unidad secundaria se conectar\u00e1 al conector intermedio. </p> <p>El revestimiento del cable de datos indica el pin 1. Conecte el cable PATA a la unidad con el indicador del pin 1 del cable alineado con el indicador del pin 1 del conector de la unidad. El indicador del pin 1 del conector de la unidad generalmente se encuentra m\u00e1s cerca del conector de alimentaci\u00f3n de la unidad. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#cables-de-datos-sata","title":"Cables de datos SATA","text":"<p>El cable de datos SATA cuenta con un conector de 7 pines. Un extremo del cable se conecta a la motherboard. El otro extremo se conecta a cualquier unidad que cuente con un conector de datos SATA. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#cables-de-datos-de-unidad-de-disquete","title":"Cables de datos de unidad de disquete","text":"<p>El cable de datos de unidad de disquete cuenta con un conector de 34 pines. Un cable de unidad de disquete generalmente cuenta con tres conectores de 34 pines. En el extremo del cable, hay un conector que se conecta a la motherboard. Los otros dos conectores se conectan a las unidades. Si se instalan varias unidades de disquete, la unidad A: se conectar\u00e1 al conector del extremo. La unidad B se conectar\u00e1 al conector intermedio. </p> <p>NOTA: Si el pin 1 del cable de datos de la unidad de disquete no est\u00e1 alineado con el pin 1 del conector de la unidad, la unidad de disquete no funcionar\u00e1. La falta de alineaci\u00f3n no  da\u00f1ar\u00e1  la  unidad.  Sin  embargo,  la  luz  de  actividad  de  la  unidad  se  encender\u00e1 continuamente.  Para  solucionar  este  problema,  apague  la  computadora  y  vuelva  a conectar el cable de datos para que el pin 1 del cable y el pin 1 del conector est\u00e9n alineados. Reinicie la computadora. </p>"},{"location":"docs/01_introduccion_sistemas_informaticos/#cables-del-panel-frontal","title":"Cables del Panel frontal","text":"<p>Los cables que provienen del frontal de la caja deben conectarse en su correspondiente conector de la placa base. Estos cables suelen venir separados y cada uno de ellos deber\u00e1 conectarse en los pines adecuados. </p> <p>El  manual  de  la  placa  base  proporciona  informaci\u00f3n  sobre  la  posici\u00f3n  correcta  de colocaci\u00f3n. </p> <p>[[Preguntas_Moodle]]</p>"},{"location":"docs/02_introduccion_sistemas_operativos/","title":"Introducci\u00f3n a los Sistemas Operativos","text":""},{"location":"docs/02_introduccion_sistemas_operativos/#software","title":"Software","text":"<p>Tal  y  como  se  define en  el  Diccionario  de  la  lengua  espa\u00f1ola,  de  la  Real Academia (DRAE), el software es el  \u00abconjunto de programas, instrucciones y reglas inform\u00e1ticas para ejecutar ciertas tareas en una computadora\u00bb.  </p> <p>Seg\u00fan  el  est\u00e1ndar  729  del  IEEE,  el  software  es  \u00abel  conjunto  de  los  programas  de c\u00f3mputo, procedimientos, reglas, documentaci\u00f3n y datos asociados que forman parte de  las  operaciones  de  un  sistema  de  computaci\u00f3n\u00bb,  lo  que  concreta  la  definici\u00f3n anterior.  </p> <p>As\u00ed  pues,  podemos  afirmar  que  el  software  es  la  parte  l\u00f3gica  de  un  ordenador,  a diferencia de la parte f\u00edsica, a la que denominamos hardware. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#software-propietario-y-software-libre","title":"Software Propietario y Software Libre","text":"<p>Es importante dejar clara la diferencia que existe entre el software libre y el software propietario.  </p> <p>El  software libre permite a los  usuarios que lo adquieren  trabajar con toda la libertad sobre \u00e9l, pudiendo usarlo, copiarlo, estudiarlo, modificarlo y distribuirlo de nuevo una vez  modificado,  y  as\u00ed  lo  indica  la  Fundaci\u00f3n  para  el Software Libre (Free Software Foundation).  </p> <p>Esto no implica expresamente que el software sea gratuito, sino que lo es el uso que se le puede dar una vez adquirido, bien sea previo pago, o bien gratuitamente. </p> <p>Lo  contrario  es  el  software  propietario,  cuyas  limitaciones  para  el  usuario  que  lo adquiere  son  la  de  copia,  modificaci\u00f3n  o  distribuci\u00f3n;  tanto  modificado  como  no modificado. </p> <p>Seg\u00fan la Fundaci\u00f3n para el Software Libre, el software propietario es cualquiera que no cumpla todas las condiciones del software libre. </p> <p>Precisamente, se denominan  \u00abcuatro libertades\u00bb aquellas que cumple por completo el software libre, y son las siguientes: </p> <ul> <li>Libertad 0: libertad para utilizar el programa con cualquier prop\u00f3sito. </li> <li>Libertad 1:  libertad para estudiar el funcionamiento del programa y adaptarlo a las necesidades del usuario. </li> <li>Libertad 2: libertad para distribuir copias del programa. </li> <li>Libertad  3:  libertad  para  modificar  el  programa,  mejor\u00e1ndolo  y  haciendo  p\u00fablicas estas mejoras al resto de usuarios, para beneficio de toda la comunidad. </li> </ul> <p>Obviamente, para poder llevar a cabo las libertades que implican la modificaci\u00f3n del programa,  es  necesario  disponer  del  c\u00f3digo  fuente,  por  lo  que  \u00e9ste  se  tiene  que distribuir para que sea considerado software libre. </p> <p>Es muy importante no confundir el t\u00e9rmino software libre (free software) con \u201cfreeware\u201d que es un tipo de software que se distribuye sin costo alguno pero que mantiene su licencia  (copyright),  por  lo  que  no  puede  modificarse  o  utilizar  libremente  como  s\u00ed puede hacerse con el software libre; en ocasiones se trata de una versi\u00f3n reducida de un programa m\u00e1s completo de pago. El freeware es una variante gratuita del shareware, el cual es un tipo de software de evaluaci\u00f3n, el cual tiene una limitaci\u00f3n en el tiempo de uso o en algunas de sus funciones para que el usuario pueda probarlo y si le gusta, lo compre habilitando toda su funcionalidad. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#clasificacion-del-software","title":"Clasificaci\u00f3n del Software","text":"<p>El  software  podemos  clasificarlo  principalmente  en  los  siguientes  tipos  seg\u00fan  su finalidad: </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#software-de-base","title":"Software de base","text":"<p>El  software  de  base,  tambi\u00e9n  denominado  \u00absoftware  de  sistema\u00bb,  es  aquel  que  nos permite interactuar directamente con el hardware de nuestro equipo, actuando como mediador entre el software de aplicaciones y el hardware del sistema.  </p> <p>Dentro  del  software  de  base  podemos  hacer  una  nueva  clasificaci\u00f3n,  donde  se encuentran los siguientes tipos de software: </p> <ul> <li>Sistemas Operativos:  son  una  parte  esencial  en  el  equipo, ya  que  se  encargan  de gestionarlo todo para que su uso resulte sencillo y efectivo para el usuario. </li> <li>Controladores  de  dispositivo:  proporcionan  al  sistema  operativo  instrucciones concretas para interactuar con los dispositivos que tiene instalados el equipo. </li> <li>Herramientas  de  diagn\u00f3stico  y  optimizaci\u00f3n:  se  encargan  de  recoger  valores  de par\u00e1metros  del  sistema  y,  si  procede,  corregirlos  para  garantizar  el  buen funcionamiento de este.</li> </ul>"},{"location":"docs/02_introduccion_sistemas_operativos/#software-de-programacion","title":"Software de programaci\u00f3n","text":"<p>Se denomina as\u00ed al conjunto de aplicaciones mediante las cuales un programador puede desarrollar sus programas inform\u00e1ticos. </p> <p>Al  igual  que  en  el  caso  anterior,  cuando  hablamos  de  este  tipo  de  software  nos referimos  a  editores  de  texto,  compiladores,  depuradores,  entornos  de  desarrollo integrados (IDE), etc.   </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#software-de-aplicacion","title":"Software de aplicaci\u00f3n","text":"<p>Se clasifican como software de aplicaci\u00f3n aquellos programas que permiten al usuario realizar tareas espec\u00edficas en el sistema.</p> <p>Este tipo de software incluye las aplicaciones ofim\u00e1ticas, software dedicado (educativo, m\u00e9dico, empresarial, etc.), aplicaciones de automatizaci\u00f3n y control industrial, software de dise\u00f1o gr\u00e1fico y multimedia, etc.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#licencias-de-software","title":"Licencias de Software","text":""},{"location":"docs/02_introduccion_sistemas_operativos/#tipos-de-licencias-genericas","title":"Tipos de licencias gen\u00e9ricas","text":"<p>El software, con independencia del tipo que sea, lleva asociado un tipo de licencia, que establece las condiciones en las que se publica, sus garant\u00edas y concesiones. </p> <p>Una misma aplicaci\u00f3n puede distribuirse con distintas licencias; por ello, estar\u00edamos hablando de aplicaciones diferentes, puesto que la licencia no es la misma. </p> <p>La multilicencia se emplea para permitir que una aplicaci\u00f3n tenga una vertiente libre, generalmente bajo varias licencias libres, y otra propietaria. </p> <p>Por  un  lado,  tenemos  el  software  privativo  con  un  copyright  con  un  conjunto  de restricciones reflejadas en el contrato que se firma entre el licenciante y el usuario del software.  De  forma  general,  este  software  no  puede  usarse  libremente,  no  puede compartirse,  no  puede  accederse  a  su  c\u00f3digo  fuente  y  no  puede  estudiarse  ni modificarse. </p> <p>Las  licencias  existentes  de  software  libre  son  much\u00edsimas,  podemos  destacar  entre ellas: </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#gnugpl-gnu-is-not-unixgeneral-public-license","title":"GNU/GPL (GNU is Not Unix/General Public License)","text":"<p>Este tipo de licencia est\u00e1 representada por Linux, y es la m\u00e1s conocida en el mundo del software libre.  Permite  tanto  la  distribuci\u00f3n  de  la  aplicaci\u00f3n  como  la de su c\u00f3digo fuente. En el caso de que \u00fanicamente se distribuyera la aplicaci\u00f3n, debe ser posible acceder  a  sus  fuentes  igualmente.  Del mismo modo,  permite  realizar modificaciones, integrando c\u00f3digo GPL.</p> <p></p> <p>El objetivo de este tipo de licencia es asegurar la libertad del c\u00f3digo, de modo  que  incluso  las modificaciones realizadas han de ser distribuidas bajo la misma licencia, y no se pueden incluir partes de c\u00f3digo patentadas si la patente no  est\u00e1  liberada.  Adem\u00e1s,  suelen  incluir  un  archivo  con  un  historial  en  el  cual  se recogen tanto las modificaciones efectuadas, como los autores involucrados en ellas. </p> <p>Una variante es la licencia LGPL (Lesser GPL), que permite utilizar  aplicaciones  libres  con  software  propietario,  de modo  que  la  aplicaci\u00f3n  es  distribuida  como  si  tuviera licencia  GPL, pero  puede  integrarse  con  otro  tipo  de software pr\u00e1cticamente sin limitaciones. Suele usarse para bibliotecas de programas, m\u00e1s que para programas ejecutables.</p> <p></p>"},{"location":"docs/02_introduccion_sistemas_operativos/#bsd-berkeley-software-distribution","title":"BSD (Berkeley Software Distribution)","text":"<p>Es una licencia que suele ser usada por los Sistemas BSD, que son sistemas operativos basados en Unix. Esta licencia al contrario que la GPL permite el uso del c\u00f3digo fuente en software privativo. </p> <p></p> <p>Es una licencia poco restrictiva, ya que permite distribuir la aplicaci\u00f3n y el c\u00f3digo fuente para ser modificados e integrados con otros programas; sin embargo, y a diferencia de otros tipos, en esta se da cr\u00e9dito a los autores. </p> <p>La  utilizan  los  desarrolladores  para  crear  aplicaciones  compatibles  basadas  en  una aplicaci\u00f3n ya existente con licencia BSD. </p> <p>Como curiosidad, saber que el S.O. macOS est\u00e1 basado en el sistema operativo BSD.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#mpl-mozilla-public-license","title":"MPL (Mozilla Public License)","text":"<p>Esta licencia fue creada por Netscape Communications para su navegador Netscape, y fue la primera con origen en una empresa, con el tiempo el control de esta licencia fue tomado por la Fundaci\u00f3n Mozilla.</p> <p></p> <p>Permite  copiar,  modificar  y distribuir ilimitadamente una aplicaci\u00f3n, sin  restringir  el  c\u00f3digo  ni  la  licencia,  dando  la  posibilidad  a  los desarrolladores  de  liberar  el  c\u00f3digo  sin  perder  el  control  sobre sus creaciones o versiones; por lo que cumple con las cuatro libertades del software. </p> <p>Se  usa  principalmente  como  licencia  para  aplicaciones  de  Mozilla,  como  son  Firefox (navegador) o Thunderbird (gestor de correo), aunque tambi\u00e9n la usan otros programas como LibreOffice 4.0. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#copyleft","title":"Copyleft","text":"<p>En este tipo de licencia, el propietario autoriza a copiar, modificar y distribuir, pero no permite agregar restricciones a la redistribuci\u00f3n o modificaci\u00f3n, que deben mantener el mismo tipo de licencia. </p> <p></p>"},{"location":"docs/02_introduccion_sistemas_operativos/#apache","title":"Apache","text":"<p>Licencia creada por Apache Software Foundation para  su  software,  aunque  en  realidad  hay muchos otros que hacen uso de ella.</p> <p></p> <p>Permite al usuario el uso sin restricciones,la distribuci\u00f3n y la modificaci\u00f3n. Sin embargo, no es copyleft ya que no exige que la distribuci\u00f3n y las obras derivadas mantengan la licencia original. De esta manera, es posible que un software abierto en origen pueda convertirse en un software cerrado aplicando esta licencia. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#tipos-de-licencias-de-sistemas-operativos","title":"Tipos de licencias de Sistemas Operativos","text":"<p>En el caso de los sistemas operativos, predominan dos tipos de licencias: la licencia EULA (Windows) y la licencia GNU/GPL (Linux). </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#licencia-eula-licencia-de-usuario-final","title":"Licencia EULA (licencia de usuario final)","text":"<p>Con esta licencia el producto solo puede ser utilizado por el usuario que lo ha adquirido. De  este  modo,  el  due\u00f1o  del  producto  obliga  al  usuario  final  a  reconocer  todas  las condiciones de la licencia, tales como las restricciones de uso, los derechos de autor y las  patentes,  as\u00ed  como  la  posibilidad  de  que  el  propietario  recoja  informaci\u00f3n  del sistema y su uso. </p> <p>Esta licencia proh\u00edbe la copia, y solo puede ser transferida una vez a otro usuario. Puede utilizarse solo en un equipo con un m\u00e1ximo de dos procesadores, que no sea servidor web ni de archivos. </p> <p>Si se efect\u00faan cambios de hardware, puede dejar de funcionar y el usuario debe activar la licencia antes de 30 d\u00edas desde su instalaci\u00f3n. Tiene una garant\u00eda de 90 d\u00edas, y no cubre las actualizaciones. </p> <p>Una de las pol\u00e9micas de EULA es que el usuario en ning\u00fan momento es due\u00f1o del producto, \u00fanicamente dispone de una licencia de uso.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#licencia-gnugpl","title":"Licencia GNU/GPL","text":"<p>Se  trata  de  la  primera  licencia  copyleft  de  uso  general,  lo  que  significa  que  las modificaciones realizadas sobre este tipo de software deben ser distribuidas bajo los t\u00e9rminos de la misma licencia GNU/GPL. </p> <p>Permite  la  copia,  modificaci\u00f3n y  redistribuci\u00f3n  de  software,  proporcionando  garant\u00eda sobre los derechos del usuario tanto de copia como de modificaci\u00f3n y redistribuci\u00f3n. Garantiza a los usuarios los derechos del software libre, aunque el  trabajo sea modificado. </p> <p>Una patente sobre este tipo de software debe ser licenciada para el beneficio de la comunidad, y esta modificaci\u00f3n no debe tener en ning\u00fan caso costo por la licencia. Adem\u00e1s, debe incluir el c\u00f3digo fuente del software desarrollado para dar al usuario la posibilidad de su modificaci\u00f3n posterior, si as\u00ed lo deseara.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#distribucion-de-licencias-propietarias","title":"Distribuci\u00f3n de licencias propietarias","text":""},{"location":"docs/02_introduccion_sistemas_operativos/#retail","title":"Retail","text":"<p>Est\u00e1 destinada a su venta directa al usuario final, aunque no est\u00e1 limitada a su equipo de destino, podemos venderla o cederla si desinstalamos el software de nuestro equipo. S\u00f3lo permite el uso en una sola m\u00e1quina a la vez, se vende con su caja y manuales. El soporte t\u00e9cnico corre a cargo del fabricante.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#oem-original-equipment-manufacturer","title":"OEM (Original Equipment Manufacturer)","text":"<p>Se encuentra ligada al equipo nuevo que se ha adquirido. No es posible vender/ceder la versi\u00f3n si no es con \u00e9l. Es m\u00e1s barata que la licencia Retail, y el soporte t\u00e9cnico corre a cuenta  del  vendedor del  equipo.  Si el vendedor  nos  proporciona el software ya preinstalado en el equipo estar\u00edamos hablando de licencia OEM por lotes. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#vlm-volume-license-manager","title":"VLM (Volume License Manager)","text":"<p>Son las llamadas licencias por volumen y son una variante de la licencia OEM. Para una empresa con cientos de ordenadores, es complicado controlar las licencias individuales de cada una de sus m\u00e1quinas. Existe la posibilidad de contratar un tipo de licencia especial con el desarrollador, de modo que, con una \u00fanica clave de licencia, podemos utilizar varias m\u00e1quinas a la vez. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#msdn","title":"MSDN","text":"<p>Son licencias especiales para un uso educativo, por lo que siempre deben activarse en equipos que tengan una finalidad did\u00e1ctica. Tambi\u00e9n existen variantes para empresas de desarrollo, academias, etc.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#sistemas-operativos-actuales","title":"Sistemas Operativos Actuales","text":""},{"location":"docs/02_introduccion_sistemas_operativos/#introduccion","title":"Introducci\u00f3n","text":"<p>En  este  apartado,  abordaremos  los  principales  sistemas  operativos  que  existen actualmente en el mercado. No vamos a ce\u00f1irnos solamente en los sistemas operativos para equipos  de  sobremesa,  sino  que  tambi\u00e9n abordaremos  sistemas  operativos de dispositivos m\u00f3viles. Pero antes de clasificarlos, vamos a estudiar qu\u00e9 es, c\u00f3mo es y qu\u00e9 hace un sistema operativo. </p> <p>El sistema operativo es el conjunto de programas del sistema inform\u00e1tico que controla los recursos hardware del ordenador y sirve de base para la ejecuci\u00f3n de los programas de aplicaci\u00f3n o de programaci\u00f3n, se le considera el intermediario entre el hardware y los programas y usuarios.</p> <p>Primero, vamos a realizar una clasificaci\u00f3n de los Sistemas operativos en funci\u00f3n de su desarrollador:</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#sistemas-operativos-linux","title":"Sistemas Operativos Linux","text":"<p>Los sistemas operativos Linux est\u00e1n desarrollados bajo la licencia GPL, por lo que se trata de un software libre, cuyo grado de libertad debe mantenerse en las diferentes distribuciones  de  este  software.  Estos  sistemas  est\u00e1n  desarrollados por una gran comunidad de empresas, asociaciones, colectivos e, incluso, por personas particulares. </p> <p>La base de este tipo de sistema es su n\u00facleo o kernel. Partiendo de diferentes versiones del kernel junto con las evoluciones que se le integran, dan lugar a una enorme variedad de distribuciones. Actualmente pueden existir m\u00e1s de 500 distribuciones diferentes de Linux. En Distrowatch puedes ver las m\u00e1s importantes.</p> <p>Las versiones sobre las que se sustentan la mayor\u00eda de distribuciones Linux actuales son: </p> <ul> <li>Slackware: slackware Linux, Open SUSE, Slax, Vector Linux, etc. </li> <li>Red Hat: Red hat Linux, CentOS, Mandriva, Fedora, etc. </li> <li>Debian: debian, Ubuntu, Knoppix, Linux Mint, etc.</li> <li>Arch: Manjaro, Endevour, Arcolinux, Garuda, etc.</li> </ul>"},{"location":"docs/02_introduccion_sistemas_operativos/#sistemas-operativos-android","title":"Sistemas operativos Android","text":"<p>Este sistema es,  en  realidad,  una  distribuci\u00f3n  de  Linux.  Dise\u00f1ado  para  dispositivos m\u00f3viles,  por  lo  que  se  ha  dise\u00f1ado  para  arquitecturas  de  equipos ARM,  aunque  hay algunas distribuciones adaptadas a x86.</p> <p>Las  distribuciones  de Android  son  \u00fanicas  para  todos  los  dispositivos  a  los  que  van dirigidas,  pero  en  funci\u00f3n  del  dispositivo  (m\u00f3vil,  Tablet, smartwatch,  etc)  usar\u00e1  una versi\u00f3n u otra.</p> <p>Android es desarrollado por Google, con el respaldo de la Open Handset Alliance, que es una  agrupaci\u00f3n  de  compa\u00f1\u00edas  para  el  desarrollo  de  est\u00e1ndares abiertos para dispositivos m\u00f3viles. </p> <p>Los  nombres  de  las  versiones  de  Android  se  corresponden  con  golosinas  o  dulces, siendo la \u00faltima versi\u00f3n conocida la Snow Cone (Android 12) lanzada en noviembre de 2022. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#sistemas-operativos-windows","title":"Sistemas Operativos Windows","text":"<p>Los sistemas operativos Windows se corresponden con una familia de distribuciones desarrolladas por la compa\u00f1\u00eda Microsoft. Todos estos SS.OO. se distribuyen bajo licencia Microsoft  EULA  y  s\u00f3lo  pueden  ser  desarrollados,  estudiados y modificados por esta compa\u00f1\u00eda. </p> <p>Estos sistemas operativos son capaces de operar tanto en arquitecturas x86, como en ARM. El primer Windows surge en 1985 cuando Microsoft incorpor\u00f3 una interfaz gr\u00e1fica a su sistema operativo MS-DOS.</p> <p>Los sistemas Windows se basan principalmente en dos arquitecturas o familias: la 9X y la NT, aunque actualmente la que domina el mercado es la familia NT, un ejemplo de ello es el actual Windows 10. </p> <p>Ahora mismo podemos encontrarnos ordenadores con las siguientes versiones:  </p> <ul> <li>Para equipos basados en la arquitectura x86 o x64: podemos encontrar con equipos con Windows 7, Windows 8, Windows 10 y Windows 11, aunque Windows 10/11 son los \u00fanicos que tienen soporte est\u00e1ndar, el resto de sistemas se encuentra en soporte extendido por lo que es conveniente dar el salto a la \u00faltima versi\u00f3n de Windows.  </li> <li>Para equipos servidores: la \u00faltima versi\u00f3n es Windows Server 2022. </li> <li>Para  tel\u00e9fonos  m\u00f3viles:  exist\u00eda una versi\u00f3n  llamada  Windows 10  Mobile, cuyo desarrollo fue suspendido por la poca cuota de mercado que ten\u00eda.  </li> </ul> <p>El objetivo actual de Microsoft con su sistema operativo Windows 10/11 es el de conseguir un sistema operativo v\u00e1lido y eficiente para las diferentes arquitecturas y dispositivos existentes en el mercado.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#sistemas-operativos-os","title":"Sistemas operativos OS","text":"<p>Estos  sistemas  operativos  tambi\u00e9n  son  conocidos  como  macOS  y  pertenecen  a  la compa\u00f1\u00eda Apple.  Esta  compa\u00f1\u00eda  se  reserva  los  derechos  de  estudio y  desarrollo  del sistema operativo, por lo que es un software privativo, cuya licencia es Apple Public Source License / Apple EULA. </p> <p>En la actualidad tenemos las siguientes versiones disponibles: </p> <ul> <li>Para los equipos de sobremesa: tenemos el sistema Mac OS X, sucesor del Mac OS 9. El OS X dispone de muchas versiones diferente siendo la m\u00e1s reciente Mac OS 13 de Junio de 2022 de nombre Ventura.</li> <li>Para equipos servidores: en estos equipos tiene una serie de versiones basadas en Unix, cuyo nombre es Mac OS X y dispone de varias versiones, siendo la m\u00e1s actual la versi\u00f3n 10.7 llamada \u201cLion\u201d de 2011. Solo funciona con los antiguos servidores PowerPC.</li> <li>Para dispositivos m\u00f3viles: los sistemas operativos de Apple para m\u00f3viles y tablets de su marca se llaman iOS, cuya \u00faltima versi\u00f3n es la 16.1, lanzada en octubre de 2022.</li> </ul>"},{"location":"docs/02_introduccion_sistemas_operativos/#otros-sistemas-operativos","title":"Otros sistemas operativos","text":"<p>Adem\u00e1s  de  estos  sistemas  operativos,  existen  otros  muchos  de  los  que  podemos destacar: </p> <ul> <li>Google Chrome OS: Sistema Open Source desarrollado por Google y basado en Linux. Funciona en arquitecturas x86 y ARM.  </li> <li>Solaris: desarrollado inicialmente por Oracle, pero actualmente en su mayor\u00eda es de c\u00f3digo abierto (Opensolaris). Su Kernel est\u00e1 basado en SunOs, que deriva de UNIX. Usa una interfaz gr\u00e1fica basada en Java. </li> <li>Berkeley Software Distribution o BSD (en espa\u00f1ol, \u00abdistribuci\u00f3n de software Berkeley\u00bb)fue unsistema operativos derivado de Unix que nace a partir de los aportes realizados a ese sistema por la Universidad de California en Berkeley. Algunos sistemas operativos descendientes del sistema desarrollado por Berkeley son SunOS, FreeBSD, NetBSD y OpenBSD. Estos, a su vez, han sido utilizados por sistemas operativos propietarios, incluidos los macOS e iOS de Apple, que se derivaron de ellos, y Microsoft Windows que usaba (al menos) parte de su c\u00f3digo TCP/IP, que era legal. El c\u00f3digo de FreeBSD tambi\u00e9n se utiliz\u00f3 para crear el sistema operativo para la PlayStation y Nintendo Switch</li> </ul>"},{"location":"docs/02_introduccion_sistemas_operativos/#clasificacion-de-los-sistemas-operativos","title":"Clasificaci\u00f3n de los Sistemas Operativos","text":"<p>El  sistema  operativo  es  un  programa  grande  y  complejo,  compuesto  por  unos componentes  con  las  funciones  bien  definidas.  Estos  componentes  se  pueden estructurar de distintas formas, haciendo que forme parte del kernel, o no. Por ello, vamos a hacer una primera clasificaci\u00f3n de los sistemas operativos seg\u00fan su n\u00facleo o kernel: </p> <ul> <li>Monol\u00edticos: no tienen una estructura clara y bien definida. Todos los componentes est\u00e1n  enlazados  en  un  \u00fanico  programa  que  se  ejecuta  en  un  \u00fanico  espacio  de direcciones. Todas  las funciones  se  ejecutan  en  modo  n\u00facleo.  Parten  de  sistemas operativos sencillos a los que se les ha ido a\u00f1adiendo muchas funcionalidades hasta convertirse en enormes y complejos. Los principales sistemas monol\u00edticos son MS- DOS,  UNIX  y  todos  sus  derivados  GNU/Linux.  Su  principal  problema  es  que  son sistemas  poco  manejables  y  poco  comprensibles.  En  estos  sistemas  todos  los procedimientos y variables son visibles por todos. Para solucionar este problema, se necesita dotar de estructura al sistema operativo. </li> <li>Sistema  monol\u00edtico  por  capas:  en  estos  sistemas,  cada  capa  implementa  una parte del sistema y las pone a la disposici\u00f3n de las capas superiores, tomando los  servicios  de  la  capa  inmediatamente  inferior.  Su  principal  ventaja  es  la modularidad  y  la  ocultaci\u00f3n;  una  capa  no  tiene  que  saber  c\u00f3mo  se  ha implementado  su  capa  inferior,  s\u00f3lo tiene  que  conocer  la  interfaz  que  ofrece. Cada  capa  puede  construirse  y  depurarse  por  separado.  Algunos  ejemplos  de sistemas por capas son: THE, OS/2 y MULTICS. </li> <li> <p>Microkernel  o  Cliente-Servidor:  implementa  la  mayor  parte  de  los  servicios  y funciones del sistema operativo en procesos de usuario, dejando s\u00f3lo una peque\u00f1a parte  del  sistema  operativo  ejecutando  en  modo  n\u00facleo.  El  n\u00facleo  realiza  unas funciones b\u00e1sicas que pueden variar, aunque suelen incluir la gesti\u00f3n de procesos, de memoria, la comunicaci\u00f3n de procesos y la gesti\u00f3n de interrupciones; mientras que las dem\u00e1s funciones son servicios ofrecidos por los servidores, que se ejecutan en modo usuario. Este sistema presenta una gran flexibilidad, el fallo en un m\u00f3dulo no hace caer todo el sistema, es f\u00e1cil de depurar. Sus principales desventajas son: es m\u00e1s dif\u00edcil de construir ya que un m\u00f3dulo debe encajar con el resto, tienen mayor carga en el tratamiento de los servicios debido al uso de espacios de direcciones distintos, por lo que su rendimiento es menor. Algunos sistemas con este n\u00facleo son: Minix, Amoeba y los actuales macOS. </p> </li> <li> <p>H\u00edbridos: Se trata de un micron\u00facleo al que se le han a\u00f1adido algunos de los servicios no  esenciales  para  que  el  S.O.  trabaje  m\u00e1s  r\u00e1pido.  Es  una  mezcla  entre  n\u00facleo monol\u00edtico y micron\u00facleo. Algunos ejemplos de sistemas operativos con este tipo de n\u00facleo son: los sistemas operativos Windows de la familia NT y DragonFly BSD.</p> </li> </ul> <p></p> <p>Otras posibles clasificaciones de los sistemas operativos seg\u00fan diferentes perspectivas son las mostradas a continuaci\u00f3n:  </p> N\u00famero de usuarios N\u00famero de tareas N\u00famero de procesadores Ofrecimiento de servicios Monousuario Monotarea Monoproceso Centralizados Multiusuario Multitarea Multiproceso Distribuidos En red De escritorio"},{"location":"docs/02_introduccion_sistemas_operativos/#principales-funciones-de-los-sistemas-operativos","title":"Principales funciones de los Sistemas Operativos","text":"<p>El sistema operativo est\u00e1 compuesto b\u00e1sicamente por tres capas: </p> <ul> <li>El n\u00facleo. (Kernel)</li> <li>Los servicios</li> <li>El int\u00e9rprete de comandos.(Shell) </li> </ul> <p></p> <p>El  n\u00facleo  es  la  parte  del  sistema  operativo  que  interacciona  directamente  con  el hardware de la m\u00e1quina. Sus principales funciones se centran en la gesti\u00f3n de recursos, como  el  procesador,  tratamiento  de  interrupciones  y  las  funciones  b\u00e1sicas  de manipulaci\u00f3n de memoria.Hay diferentes tipos de kernels, como veremos m\u00e1s adelante. </p> <p>Los  servicios se agrupan seg\u00fan su funcionalidad en varios componentes, los cuales se ocupan de las principales funciones del sistema operativo. </p> <ul> <li>Gesti\u00f3n  de  procesos:  se  encarga  de  la  creaci\u00f3n,  planificaci\u00f3n  y  destrucci\u00f3n  de procesos. </li> <li>Gesti\u00f3n de memoria: gestiona las partes de memoria libres y ocupadas, as\u00ed como de asignar y liberar la memoria para los diferentes procesos. </li> <li>Gesti\u00f3n de la E/S: facilita la comunicaci\u00f3n con los diferentes dispositivos perif\u00e9ricos. </li> <li>Gesti\u00f3n de archivos y directorios: se encarga del manejo de archivos y directorios y de la administraci\u00f3n del almacenamiento secundario. </li> <li>Comunicaci\u00f3n  y  sincronizaci\u00f3n  entre  procesos:  encargada  de  ofrecer mecanismos para que los procesos puedan comunicarse y sincronizarse. </li> <li>Seguridad y protecci\u00f3n: se encarga de garantizar la identidad de los usuarios y definir el nivel de permisos de acceso o modificaci\u00f3n de los diferentes recursos del sistema. </li> </ul> <p>Estos  servicios  se  ofrecen  mediante  una  interfaz  de  llamadas  al  sistema  (API  \u2013 Application  Programming  Interface).  En  un  mismo  sistema  operativo  se  puede  incluir m\u00e1s de una API. Las APIs mostradas son: </p> <ul> <li>Windows API: para los sistemas operativos Windows, tambi\u00e9n llamada Win32. </li> <li>POSIX: para los sistemas operativos basados en UNIX, como las distribuciones GNU/ Linux. </li> <li>COCOAAPI: interfaz para los \u00faltimos sistemas de macOS X, totalmente compatible con sistemas de 64 bits. </li> </ul> <p>El Shell o int\u00e9rprete de comandos suministra una interfaz a trav\u00e9s de la cual el usuario puede  interaccionar  con  la  computadora,  facilitando  el  acceso  a  las  funciones  del n\u00facleo. El int\u00e9rprete recibe las \u00f3rdenes del usuario, los interpreta y, si es posible y est\u00e1 permitido, los ejecuta. Este int\u00e9rprete en ocasiones se considera que forma parte del sistema operativo y en otras ocasiones no. Estos int\u00e9rpretes pueden ser de varios tipos: </p> <ul> <li>Interfaz gr\u00e1fica de usuario (GUI - Graphic User Interface)</li> <li>Interfaz de l\u00ednea de comandos (Consola o terminal o CLI - Command Line Interpreter)</li> </ul> <p>El sistema operativo puede incluir varios interfaces, tanto en modo texto como gr\u00e1ficos, entre los cuales podemos optar seg\u00fan nos interese y disponibilidad.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#gestion-de-procesos","title":"Gesti\u00f3n de procesos","text":""},{"location":"docs/02_introduccion_sistemas_operativos/#introduccion_1","title":"Introducci\u00f3n","text":"<p>Ya hemos dicho que el n\u00facleo es la parte del sistema operativo que interacciona directamente con el hardware de la m\u00e1quina. Una de las principales funciones del sistema operativo es la gesti\u00f3n de procesos, para ello se utilizan una serie de algoritmos que nacieron por la necesidad de poder ordenar los procesos para ganar eficiencia a la hora de tratar con ellos. Es decir, son los encargados de ordenar y dirigir los procesos para asegurar que ninguno de ellos monopolice el uso de la CPU.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#conceptos-basicos","title":"Conceptos b\u00e1sicos.","text":"<p>Antes de ver algunos de los algoritmos m\u00e1s utilizados vamos a definir algunos conceptos b\u00e1sicos: </p> <ul> <li>Tiempo de espera: el tiempo que un proceso permanece en espera en la cola de ejecuci\u00f3n. </li> <li>Tiempo de retorno: tiempo que va desde que se lanza un proceso hasta que finaliza. </li> <li>Tiempo de respuesta: tiempo que un proceso bloqueado tarda en entrar en ejecuci\u00f3n. </li> <li>Uso de CPU: porcentaje de tiempo que la CPU est\u00e1 ocupada. </li> <li>Productividad: n\u00famero de procesos realizados en una unidad de tiempo. </li> </ul> <p>Por \u00faltimo, dos algoritmos: </p> <ul> <li>Apropiativo: tambi\u00e9n conocido como expulsivo o expropiativo. Nos permite la expulsi\u00f3n de procesos para ejecutar un nuevo proceso, poniendo en cola al anterior. </li> <li>No apropiativo: No nos permite la expulsi\u00f3n, por lo que un proceso nuevo no entrar\u00e1 hasta que termine el anterior. </li> </ul>"},{"location":"docs/02_introduccion_sistemas_operativos/#tipos-de-algoritmos","title":"Tipos de algoritmos.","text":""},{"location":"docs/02_introduccion_sistemas_operativos/#fcfs-first-come-first-served","title":"FCFS (First-Come, First-Served)","text":"<p>Tambi\u00e9n llamado FIFO (First In, First Out). Este algoritmo es muy sencillo y simple, pero tambi\u00e9n el que menos rendimiento ofrece. B\u00e1sicamente, en este algoritmo, el primer proceso que llega se ejecuta y, una vez finalizado se ejecuta el siguiente. No apropiativo. Penaliza a los procesos cortos. </p> <p>Ejemplo:</p> Procesos Llegada Tiempo uso CPU P1 0 24 P2 2 3 P3 4 3 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 P1 X X X X X X X X X X X X X X X X X X X X X X X F P2 E E E E E E E E E E E E E E E E E E E E E E X X F P3 E E E E E E E E E E E E E E E E E E E E E E E X X F <p></p> <p>Tiempo de retorno = tiempo de finalizaci\u00f3n - tiempo de llegada</p> <p>Tiempo de espera = tiempo de retorno - tiempo de servicio</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#sjf-shortest-job-first","title":"SJF (Shortest Job First)","text":"<p>Este algoritmo siempre prioriza los procesos m\u00e1s cortos primero, independientemente de su llegada. En caso de que los procesos sean iguales, utilizar\u00e1 el m\u00e9todo FIFO (es decir, el orden seg\u00fan su entrada). Este algoritmo corre el riesgo de poner siempre al final de la cola los procesos m\u00e1s largos, por lo que nunca se ejecutar\u00e1n. Esto se conoce como inanici\u00f3n. Es un m\u00e9todo no apropiativo. Solo se puede usar si se conoce de antemano la duraci\u00f3n de cada trabajo. </p> <p>Ejemplo:</p> Procesos Llegada Tiempo uso CPU P1 0 7 P2 2 4 P3 4 1 P4 5 4 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 P1 X X X X X X F P2 E E E E E E X X X F P3 E E E F P4 E E E E E E E X X X F <p></p>"},{"location":"docs/02_introduccion_sistemas_operativos/#srtf-short-remaining-time-next","title":"SRTF (Short Remaining Time Next)","text":"<p>Si a\u00f1adimos la expulsi\u00f3n de procesos al algoritmo SJF, obtendremos el SRTF. \u00c9ste ser\u00e1 capaz de expulsar un proceso largo en ejecuci\u00f3n para ejecutar otros m\u00e1s cortos. El problema que puede surgir es que un proceso largo puede llegar a expulsarse muchas veces y nunca terminar debido a la ejecuci\u00f3n de otros m\u00e1s cortos. </p> <p>Ejemplo: </p> Procesos Llegada Tiempo uso CPU P1 0 7 P2 2 4 P3 4 1 P4 5 4 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 P1 X X E E E E E E E E E X X X X F P2 X X E X F P3 F P4 E E X X X F <p></p>"},{"location":"docs/02_introduccion_sistemas_operativos/#round-robin","title":"Round Robin","text":"<p>Este algoritmo asigna a cada proceso un tiempo equitativo tratando a todos los procesos por igual y con la misma prioridad. </p> <p>Este algoritmo es circular, volviendo siempre al primer proceso una vez terminado con el \u00faltimo. Para controlar este m\u00e9todo, a cada proceso se le asigna un intervalo de tiempo llamado quantum o cuanto (para definirlo se utiliza esta regla, el 80% de los procesos tienen que durar menos tiempo que el quantum definido). </p> <p>Pueden suceder dos casos con este m\u00e9todo: </p> <ul> <li>El proceso es menor que el quantum: al terminar antes, se planifica un nuevo proceso. </li> <li>El proceso es mayor que el quantum: al terminar el quantum se expulsa el proceso dando paso al siguiente proceso en la lista. Al terminar la iteraci\u00f3n se volver\u00e1 para terminar el primer proceso expulsado. </li> </ul> <p>Algoritmo apropiativo. Se debe tener en cuenta que cada cambio de contexto genera retraso.</p> Procesos Llegada Tiempo uso CPU P1 0 10 P2 1 4 P3 2 3 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 P1 X X X X E E E E X X X X E E E X F P2 E E E X X X F P3 E E E E E E E E E E X X F <p></p>"},{"location":"docs/02_introduccion_sistemas_operativos/#gestion-de-memoria","title":"Gesti\u00f3n de Memoria","text":"<p>En un sistema monoprogramado (lo contrario que multiprogramado), en la memoria del ordenador solo hay un \u00fanico programa, acompa\u00f1ado de sus datos y del sistema operativo. Esto hace que el uso de la memoria, y la asignaci\u00f3n de la misma al programa sea muy simple. Sin embargo, en un sistema multiprogramado nos vamos a encontrar en memoria con varios programas a la vez (2 en el mejor de los casos, pero podemos realizar multiprogramaci\u00f3n con 20, 100 o 700 procesos). </p> <p></p> <p>Este \u201clio\u201d que vemos en la memoria usando multiprogramaci\u00f3n hace que se presenten dos problemas fundamentales, la relocalizaci\u00f3n y la protecci\u00f3n. </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#problemas-con-la-memoria","title":"Problemas con la memoria","text":""},{"location":"docs/02_introduccion_sistemas_operativos/#relocalizacion","title":"Relocalizaci\u00f3n","text":"<p>Consiste en que los programas que necesitan cargarse en memoria real ya est\u00e1n compilados y montados, de manera que internamente contienen una serie de referencias a direcciones de instrucciones, rutinas y procedimientos que ya no son v\u00e1lidas en el espacio de direcciones de memoria real de la secci\u00f3n en la que se carga el programa.  Esto  es,  cuando  se  compil\u00f3  el  programa  se  definieron  o  resolvieron  las direcciones de memoria de acuerdo a la secci\u00f3n de ese momento, pero si el programa se carga en otro d\u00eda en una secci\u00f3n diferente, las direcciones reales ya no coinciden.  </p> <p>Si en memoria solo va a estar este programa, no hay problemas en cargarlo siempre en la misma direcci\u00f3n o secci\u00f3n de memoria, pero si cargamos varios programas en la memoria, esto ya no es posible, dado que varios programas podr\u00edan pedir la misma secci\u00f3n. </p> <p></p> <p>En este ejemplo te\u00f3rico que vemos arriba, el proceso A est\u00e1 preparado para cargarse en la direcci\u00f3n de memoria 256.212. Mientras que solo dicho proceso est\u00e9 funcionando en memoria no hay problema en esto.  </p> <p></p> <p>En este ejemplo te\u00f3rico de arriba, vemos como al mismo tiempo que el proceso A, intentamos ejecutar un proceso B que quiere cargarse en la direcci\u00f3n de memoria 310.815... vemos como \u201cmachaca\u201d al proceso A, y  tambi\u00e9n  sus  datos.  Esto  conllevar\u00eda  que  ambos  procesos  dejar\u00edan  de  funcionar,  ya  que  ir\u00edan sobrescribi\u00e9ndose el uno al otro.  </p> <p>El gestor o controlador de memoria del sistema operativo, puede solucionar este problema de varias formas, una de las m\u00e1s usadas consiste en tener un registro que guarde la direcci\u00f3n base de la secci\u00f3n que va a contener al programa. Cada vez que el programa haga una referencia a una direcci\u00f3n de memoria, se le suma el registro base para encontrar la direcci\u00f3n real. As\u00ed, en el ejemplo anterior tendr\u00edamos que cuando el proceso A quiere acceder a la memoria para instalarse en la direcci\u00f3n 256.212, el SO (Sistema Operativo) hace la operaci\u00f3n (direcci\u00f3n + base) donde base por ejemplo es 20.000 por lo que el proceso A ser\u00eda cargado en la direcci\u00f3n 276.212. Cuando el proceso B se quiera cargar, el SO ajusta la base por ejemplo a 500.000 (para saltarse al proceso  A), de forma que en lugar de instalarse en la direcci\u00f3n 310.815 se instalar\u00e1 en la direcci\u00f3n 810.815.  </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#proteccion","title":"Protecci\u00f3n","text":"<p>Este problema se refiere a que, una vez que un programa ha sido cargado a memoria en alg\u00fan segmento en particular, nada le impide al programador que intente direccionar (por error o deliberadamente) localidades de memoria menores que el l\u00edmite inferior de su programa o superiores a la direcci\u00f3n mayor; es decir, quiere referenciar localidades fuera de su espacio de direcciones.  </p> <p></p> <p>Obviamente, este es un problema de protecci\u00f3n, ya que no es legal leer o escribir en \u00e1reas de memoria que pertenezcan a otros programas, y hay que proteger estas zonas de memoria.  </p> <p>La soluci\u00f3n a este problema puede ser el uso de un registro base y un registro l\u00edmite. El registro base contiene la direcci\u00f3n del comienzo de la secci\u00f3n que contiene el programa, mientras que el l\u00edmite contiene la direcci\u00f3n donde termina. Cada vez que el programa hace una referencia a memoria se comprueba si cae en el rango de los registros y si no es as\u00ed se env\u00eda un mensaje de error y se aborta el programa.  </p> <p>Muchos  programas  antiguos  dan  errores  de  acceso  a  memoria  cuando  son  ejecutados  en  sistemas multiprogramados. Precisamente estos errores vienen dados porque intentan acceder a direcciones de memoria que quedan fuera de su \u00e1mbito.  </p> <p>En estos casos, el sistema operativo impide que dichos programas accedan a esas direcciones, lo que provoca un error en el acceso a memoria.</p> <p></p>"},{"location":"docs/02_introduccion_sistemas_operativos/#memoria-virtual","title":"Memoria virtual","text":"<p>Las  CPU  de  los  ordenadores  eran  cada  vez  m\u00e1s poderosas, lo que permit\u00eda ejecutar programas cada  vez m\u00e1s potentes, y por lo tanto m\u00e1s grandes.</p> <p></p> <p>Al mismo tiempo, el uso de la multiprogramaci\u00f3n, hac\u00eda  que  el  sistema  operativo  tuviera  que  colocar  por  decenas  de  estos  grandes  procesos  en  la memoria RAM.    </p> <p>El  problema  es  que  la  cantidad  de  memoria  RAM  \u201cf\u00edsica\u201d  que  podemos  instalar  en  un  ordenador  es  finita,  es  decir,  tiene  un  l\u00edmite.  As\u00ed,  si  intentamos  ejecutar en multiprogramaci\u00f3n 20 procesos, y cada uno de ellos necesita 512 MB de RAM para trabajar, deber\u00edamos tener instalados en nuestro main memory ordenador 10 GB de RAM.  </p> <p>Todo esto empuj\u00f3 a los dise\u00f1adores de los sistemas operativos a implantar un mecanismo que permitiera ofrecer a los procesos m\u00e1s cantidad de memoria de la que realmente estaba instalada en la m\u00e1quina, esto es, de ofrecer \"memoria virtual\u201d.  </p> <p>La memoria virtual se llama as\u00ed porque el programa ve una cantidad de memoria mucho mayor que la real, y que en realidad se trata de la suma de la memoria de almacenamiento primario y una cantidad determinada de almacenamiento secundario (por ejemplo, del disco duro).  </p> <p>El sistema operativo, en su m\u00f3dulo de gesti\u00f3n de memoria, se encarga de intercambiar programas enteros, segmentos  o  p\u00e1ginas  entre  la  memoria  real  y  el  medio  de  almacenamiento  secundario.  Si  lo  que  se intercambia son procesos enteros, se habla entonces de multiprogramaci\u00f3n en memoria real, pero si lo que se intercambian son segmentos o p\u00e1ginas, se puede hablar de multiprogramaci\u00f3n con memoria virtual.  </p> <p>Existe una t\u00e9cnica en la cual, el sistema operativo divide a los procesos en peque\u00f1as porciones, de tama\u00f1o fijo denominadas p\u00e1ginas, de un tama\u00f1o m\u00faltiplo de 1 K. Estas p\u00e1ginas van a ser pasadas de la RAM al disco y viceversa. Al proceso de intercambiar p\u00e1ginas, segmentos o programas completos entre RAM y disco se le conoce como 'intercambio' o \u2018swapping\".  </p> <p>En la paginaci\u00f3n, se debe cuidar el tama\u00f1o de las p\u00e1ginas, ya que si \u00e9stas son muy peque\u00f1as el control por parte del sistema operativo para saber cu\u00e1les est\u00e1n en RAM y cu\u00e1les en disco, sus direcciones reales, etc, crece y provoca mucha \"sobrecarga' (overhead). Por otro lado, si las p\u00e1ginas son muy grandes, el overhead disminuye, pero entonces puede ocurrir que se desperdicie memoria en procesos peque\u00f1os. Debe haber un equilibrio entre ambos conceptos.  </p> <p>Otro aspecto importante es la estrategia para cargar p\u00e1ginas (o segmentos) a la memoria RAM. Se usan m\u00e1s com\u00fanmente  dos  estrategias:  cargado  de  p\u00e1ginas  por  demanda  y  cargado  de  p\u00e1ginas  anticipada.  La estrategia de cargado y por demanda consiste en que las p\u00e1ginas solamente son llevadas a RAM si son solicitadas, es decir, si se hizo referencia a una direcci\u00f3n que cae dentro de ellas.  </p> <p>La carga anticipada consiste en tratar de adivinar qu\u00e9 p\u00e1ginas ser\u00e1n solicitadas en el futuro inmediato y cargarlas de antemano, para que cuando se pidan ya no ocurran fallos de p\u00e1gina. Ese \"adivinar' puede ser que se aproveche del fen\u00f3meno de localidad y que las p\u00e1ginas que se cargan por anticipado sean aquellas que contienen direcciones contiguas a la direcci\u00f3n que se acaba de referenciar. En el caso de Windows, se usa una conjunci\u00f3n de ambos m\u00e9todos, y se utiliza un fichero en disco duro donde se va almacenando toda la informaci\u00f3n sobre  \u00edndices de p\u00e1ginas en HD, en RAM, etc. Este fichero se denomina  pagefile.sys  y  lo  pod\u00e9is  encontrar  normalmente  en  la  ra\u00edz  de  vuestro volumen de sistema.   </p> <p>Un problema que tenemos con la memoria virtual es la diferencia  de velocidad enorme que existe entre la RAM y la memoria de  almacenamiento  secundario.  Si  cargamos  muchos  procesos,  y  agotamos nuestra memoria RAM real, el SO permitir\u00e1 que todo  siga funcionando, usando el HD, pero tardar\u00e1 much\u00edsimo en pasar  las p\u00e1ginas de RAM a HD y viceversa. En muchas ocasiones, nos  parecer\u00e1 incluso que el SO se ha quedado \u201ccolgado\u201d. Esto es muy  habitual en sistemas con poca memoria, donde vemos que de  repente la luz indicadora de actividad en los discos duros se queda  encendida, y el SO deja de responder durante un buen rato.   </p> <p>Un intento de solucionar esto es usar memorias de estado s\u00f3lido en lugar del HD para paginar ya que son memorias mucho m\u00e1s r\u00e1pidas, esto fue implementado desde Windows Vista.  </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#sistema-de-ficheros-fs-file-system","title":"Sistema de Ficheros (FS.- File System)","text":"<p>Un fichero es un mecanismo de abstracci\u00f3n que sirve como unidad l\u00f3gica de almacenamiento de informaci\u00f3n. El fichero agrupa una colecci\u00f3n de informaciones relacionadas entre s\u00ed y definidas por su creador. A todo fichero le corresponde un nombre \u00fanico que lo identifique entre los dem\u00e1s ficheros.   </p> <p>Es necesario que el sistema operativo cuente con un sistema que se encargue de administrar la informaci\u00f3n almacenada en los dispositivos en forma de ficheros: de esto se encargan los sistemas de ficheros.   </p> <p>Un sistema de ficheros es el aspecto m\u00e1s visible de todo sistema operativo y existe por razones tecnol\u00f3gicas, ya que no hay memoria principal lo suficientemente grande como para no necesitar de almacenamiento secundario. Surge debido a la necesidad del sistema operativo de poder gestionar la informaci\u00f3n de forma eficiente y estructurada, adem\u00e1s de establecer unos par\u00e1metros de seguridad y protecci\u00f3n en entornos cr\u00edticos.  </p> <p>El sistema operativo ofrece una visi\u00f3n l\u00f3gica y uniforme del almacenamiento de informaci\u00f3n realizando una abstracci\u00f3n de las propiedades f\u00edsicas de sus dispositivos de almacenamiento. Para ello, define el concepto l\u00f3gico de fichero. El sistema operativo se debe encargar del acoplamiento entre los ficheros y los dispositivos f\u00edsicos, por medio del sistema de ficheros, que debe ser independiente del soporte f\u00edsico concreto sobre el que se encuentre.   </p> <p>Los objetivos principales de todo sistema de ficheros deben ser los siguientes: Crear, borrar y modificar ficheros.  </p> <ul> <li>Permitir el acceso controlado a la informaci\u00f3n.  </li> <li>Permitir intercambiar datos entre ficheros.  </li> <li>Poder efectuar copias de seguridad recuperables. </li> <li>Permitir el acceso a los ficheros mediante nombres simb\u00f3licos.   </li> </ul> <p>Hay otros objetivos secundarios, entre los que destacan:   </p> <ul> <li>Optimizar el rendimiento.  </li> <li>Tener soportes diversos para E/S (para poder seguir utilizando los mismos ficheros, aunque cambie el soporte). </li> <li>Ofrecer soporte multiusuario. </li> <li>Minimizar las p\u00e9rdidas de informaci\u00f3n.   </li> </ul> <p>Normalmente los ficheros se organizan en directorios (tambi\u00e9n llamados carpetas) para facilitar su uso. Estos directorios son ficheros que contienen informaci\u00f3n sobre otros ficheros: no son m\u00e1s que contenedores de secuencias de registros, cada uno de los cuales posee informaci\u00f3n acerca de otros ficheros. </p> <p>La informaci\u00f3n que contiene un fichero la define su creador. Hay muchos tipos diferentes de informaci\u00f3n que puede almacenarse en un fichero: programas fuente, programas objeto, datos num\u00e9ricos, textos, registros contables, fotograf\u00edas, videos, etc. Un fichero tiene una cierta estructura, definida seg\u00fan el uso que se vaya a hacer de \u00e9l.  </p> <p>Por ejemplo, un fichero de texto es una secuencia de caracteres organizados en l\u00edneas (y posiblemente en p\u00e1ginas); un fichero fuente es una secuencia de subrutinas y funciones, un fichero gr\u00e1fico es una secuencia que permite dibujar pixeles en pantalla, etc.  </p> <p>Cualquier sistema operativo distingue entre varios tipos b\u00e1sicos de ficheros, que ser\u00e1 la clasificaci\u00f3n que consideremos nosotros: </p> <ul> <li>Regulares o Normales: Aquellos ficheros que contienen datos (informaci\u00f3n).  </li> <li>Directorios: Aquellos ficheros cuyo contenido es informaci\u00f3n sobre otros ficheros, normalmente un vector de entradas con informaci\u00f3n sobre los otros ficheros. </li> <li>De dispositivo: Existen dispositivos cuya E/S se realiza como si fuesen ficheros, por lo tanto, es razonable asociarles ficheros para simplificar y hacer m\u00e1s transparente el intercambio de informaci\u00f3n con dichos dispositivos.  </li> </ul> <p>Aunque se imponga al sistema operativo el desconocimiento del tipo de ficheros que manipula, s\u00ed se hace una distinci\u00f3n del mismo de forma transparente: a trav\u00e9s de las extensiones del nombre. Mediante la extensi\u00f3n del nombre del fichero (una cadena de caracteres de peque\u00f1a longitud) se puede determinar el tipo del fichero. Algunos sistemas de ficheros consideran a la extensi\u00f3n como una parte del nombre (y, de hecho, admiten que un mismo fichero posea varias extensiones anidadas), y otros la diferencian del nombre a nivel interno. </p> <p>De este modo, aunque el sistema operativo no conozca internamente la estructura de los ficheros, si es capaz de manejarlos eficientemente gracias al uso de estas extensiones. Esta es la aproximaci\u00f3n de los sistemas operativos de Microsoft. </p> <p>Unix y sus variantes (Linux) sin embargo, optan por la no utilizaci\u00f3n de extensiones, lo que implica que el usuario es el \u00fanico encargado de saber lo que se puede realizar o no con un fichero dado.   </p> <p>10.1 ESTRUCTURAS DE DIRECTORIOS.  </p> <p>Veamos el siguiente ejemplo: Imaginemos un bufete de abogados que dispone de una ingente cantidad de informaci\u00f3n en papel: casos judiciales, precedentes, historiales de abogados, historiales de clientes, n\u00f3minas, cartas recibidas, copias de cartas enviadas, facturas del alquiler del local, albaranes de compra de lapiceros, procedimientos, etc.   </p> <p>Ahora supongamos que todos estos documentos se almacenan en una enorme monta\u00f1a de papel en el centro de  una  habitaci\u00f3n:  la  locura  est\u00e1  garantizada.  Obviamente  el  bufete  debe  disponer  de  un  armario  de archivadores, la informaci\u00f3n se podr\u00e1 almacenar de forma l\u00f3gica para poder acceder a ella r\u00e1pidamente cuando sea necesario.   </p> <p>Lo mismo ocurre en un sistema de ficheros inform\u00e1tico: conviene guardar la informaci\u00f3n (los ficheros) en archivadores. Los archivadores ser\u00e1n lo que llamaremos directorios, un tipo especial de ficheros donde se almacena informaci\u00f3n relativa a otros ficheros.   </p> <p>As\u00ed, en un directorio se almacenar\u00e1n ficheros relacionados entre s\u00ed, y ficheros totalmente independientes ir\u00e1n alojados en distintos directorios. Evidentemente, esta organizaci\u00f3n es puramente l\u00f3gica: todos los ficheros estar\u00e1n almacenados f\u00edsicamente en el mismo lugar.   </p> <p>Hay varias formas de organizar los directorios sobre un disco: </p> <p></p> <ul> <li>Directorio de un nivel. En este tipo de organizaci\u00f3n solo se permite  un nivel de directorio.   </li> <li>Directorio de dos niveles. En este tipo de organizaci\u00f3n, un directorio  puede incluir dentro otro directorio, pero este ya no puede incluir  otro m\u00e1s.  </li> <li>Directorio  con  estructura  arborescente.  Pr\u00e1cticamente  no  tiene  limitaciones.  Un  directorio  puede  incluir  otros  directorios,  sin  importar su n\u00famero, y estos nuevos directorios pueden contener  otros directorios.    </li> </ul> <p>De esta forma, cada usuario puede crear sus propios directorios para organizar sus ficheros a su gusto. Un ejemplo de estructura de directorios de esta forma es la considerada por los sistemas de ficheros de Unix, MS-DOS, Windows, etc.   </p> <p>El \u00e1rbol es de ra\u00edz \u00fanica, de modo que cada fichero tiene un \u00fanico nombre de ruta de acceso. El nombre de ruta  de  acceso  en  un  directorio  de  esta  forma  es  la  concatenaci\u00f3n  de  los  nombres  de  directorio  y subdirectorios desde el directorio ra\u00edz hasta el directorio donde se encuentra alojado el fichero a trav\u00e9s del camino \u00fanico, culminando con el propio nombre del fichero dentro del directorio. </p> <p>Un directorio (o subdirectorio) contiene a su vez ficheros y/o subdirectorios, y todos los directorios poseen el mismo formato interno. Las entradas del directorio indican si el objeto referenciado es un fichero o un subdirectorio.   </p> <p>Se define directorio padre de un fichero o subdirectorio como el directorio en el que se encuentra su entrada de referencia Cada fichero o directorio (a excepci\u00f3n del directorio ra\u00edz) posee un \u00fanico directorio padre. El directorio padre suele ser referenciado por los sistemas operativos con punto punto (..).   </p> <p>Se define directorio hijo de un directorio como el directorio que tiene por padre al primero. Un directorio puede contener m\u00faltiples directorios hijos, y cada directorio (a excepci\u00f3n del ra\u00edz) es hijo de alg\u00fan otro.   </p> <p>Se define directorio actual como aquel en el que trabaja el usuario por defecto. Suele ser referenciado por los sistemas operativos con un punto (.). Cuando el usuario hace referencia a un fichero por nombre (no por nombre de ruta de acceso), el sistema inicia la b\u00fasqueda siempre en el directorio actual. Si no lo encuentra, comienza a recorrer el camino de b\u00fasqueda hasta dar con \u00e9l. El usuario puede referirse a un fichero tambi\u00e9n por su nombre de ruta de acceso, en cuyo caso no se da lugar a emplear el camino de b\u00fasqueda. El usuario tambi\u00e9n puede cambiar su directorio actual, especificando un nombre de directorio.   </p> <p>En este caso, los nombres de ruta de acceso pueden adoptar dos formas alternativas.  </p> <p>La primera es la del nombre de ruta absoluto, la que hemos definido, por la cual se nombra a cada fichero con respecto al directorio ra\u00edz.   </p> <p></p> <p>Por ejemplo, un nombre de ruta absoluto v\u00e1lido es C:  </p> <p><code>\\Documentos\\Jose\\Privado\\Carta.txt</code>. Normalmente, se denota el directorio ra\u00edz por medio de un s\u00edmbolo especial dependiente de cada sistema de ficheros, aunque los m\u00e1s habituales son los s\u00edmbolos '/' y '\\'. En una estructura de directorio de este tipo, el nombre de ruta de acceso absoluto de un fichero o directorio debe ser \u00fanico.   </p> <p>La segunda opci\u00f3n es la del nombre de ruta relativo. En este caso, se nombra al fichero con respecto al directorio actual. Para esta labor se definen en cada directorio dos entradas de directorio especiales: <code>.</code> (Un punto) que representa al propio directorio y <code>..</code> (Dos puntos), que representa a su directorio padre. As\u00ed, se puede considerar un camino \u00fanico desde el directorio actual hasta cualquier fichero o directorio del sistema. Un ejemplo de ruta relativa v\u00e1lida podr\u00eda ser por ejemplo <code>..\\Privado\\Carta.txt</code> o <code>Jose\\Privado\\Carta.txt</code>.   </p> <p>Los ficheros se van almacenando en el dispositivo, y por cada uno de ellos se apunta una entrada de directorio, donde almacenamos informaci\u00f3n sobre el tipo de fichero, nombre y dem\u00e1s. Hay que notar que por cada fichero se almacena por un lado el propio fichero, los datos, y por otro lado se almacena esta entrada de directorio.  </p> <p>Pero \u00bfqu\u00e9 se almacena realmente en una entrada de directorio? La siguiente tabla muestra algunas de estas informaciones, aunque en un sistema de ficheros concreto pueden no estar todas las que son ni ser todas las que est\u00e1n:   </p> Atributo Cometido Nombre del fichero El nombre simb\u00f3lico del fichero Tipo de fichero Para aquellos sistemas que contemplan diferentes tipos Ubicaci\u00f3n Un puntero al dispositivo y a la posici\u00f3n del fichero en el dispositivo. Tama\u00f1o Tama\u00f1o actual del fichero (en bytes, palabras o bloques) y el m\u00e1ximo tama\u00f1o permitido. Posici\u00f3n actual Un puntero a la posici\u00f3n actual de lectura o escritura sobre el fichero. Su lugar exacto en el dispositivo. Protecci\u00f3n Informaci\u00f3n referente a los permisos de acceso al fichero. Contador de uso N\u00famero de procesos que est\u00e1n utilizando simult\u00e1neamente el fichero. Hora y fecha De creaci\u00f3n, \u00faltimo acceso, etc. Identificaci\u00f3n Del proceso creador del fichero, del \u00faltimo que accedi\u00f3 al fichero, en qu\u00e9 forma lo hizo, etc. Seg\u00fan el sistema concreto, una entrada de directorio puede ocupar desde una decena hasta varios miles de bytes. Por esta raz\u00f3n, la estructura de directorios suele almacenarse en el propio dispositivo que se est\u00e1 organizando, como un fichero especial.  La forma de almacenar los directorios en el dispositivo (estructura de datos del directorio) var\u00eda tambi\u00e9n de un sistema a otro. La forma m\u00e1s sencilla es la de una lista lineal, de forma que cada entrada se encuentra inmediatamente a continuaci\u00f3n de la precedente. Esto sin embargo es muy caro en ejecuci\u00f3n, pues la b\u00fasqueda de una entrada concreta suele exigir pasar por todas las anteriores (b\u00fasqueda lineal). Hay otros problemas, como el de qu\u00e9 hacer cuando se elimine una entrada (algunos sistemas la marcan como borrada para su posterior utilizaci\u00f3n, otros la incluyen en una lista de entradas libres). <p>Otra opci\u00f3n es mantener una lista lineal ordenada, pero exige el mantener permanentemente ordenada la lista lo que complica excesivamente las operaciones de borrado y creaci\u00f3n de entradas y la complicaci\u00f3n del algoritmo de b\u00fasqueda. Puede pensarse entonces en emplear un \u00e1rbol binario de b\u00fasqueda, que simplifica las operaciones antes mencionadas (y complica el algoritmo de b\u00fasqueda). </p>"},{"location":"docs/02_introduccion_sistemas_operativos/#capas","title":"Capas","text":"<p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas. Para crear una imagen, generalmente se crea el archivo de texto <code>dockerfile</code> formado por diferentes instrucciones. Cada l\u00ednea representa una instrucci\u00f3n, y cada vez que se ejecuta el dockerfile se ejecutan dichas instrucciones de arriba a abajo. Estos <code>dockerfile</code>-s se almacenan como texto y se pueden compartir con facilidad, as\u00ed como almacenarse en sistemas de control de versiones. Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior. La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa. Cada imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados. Al final del <code>dockerfile</code>, la \u00faltima instrucci\u00f3n define el comando que se ejecutar\u00e1 cuando arranquemos el contenedor. Al ejecutar un comando a partir de la imagen creada, se ejecuta el comando especificado y se convierte en el proceso con PID 1 dentro del \u00e1rbol virtual de procesos. El contenedor seguir\u00e1 en marcha mientras el proceso creado siga en ejecuci\u00f3n.</p>"},{"location":"docs/02_introduccion_sistemas_operativos/#capas_1","title":"Capas","text":"<p>Las im\u00e1genes se construyen sobre una tecnolog\u00eda de sistema de ficheros por capas. Para crear una imagen, generalmente se crea el archivo de texto <code>dockerfile</code> formado por diferentes instrucciones. Cada l\u00ednea representa una instrucci\u00f3n, y cada vez que se ejecuta el dockerfile se ejecutan dichas instrucciones de arriba a abajo. Estos <code>dockerfile</code>-s se almacenan como texto y se pueden compartir con facilidad, as\u00ed como almacenarse en sistemas de control de versiones. Cada instrucci\u00f3n que se ejecuta cambia ligeramente el estado del sistema de archivos respecto a la instrucci\u00f3n anterior. La diferencia entre el estado del sistema de ficheros antes y despu\u00e9s de cada instrucci\u00f3n se guarda en disco como un archivo, que conforma una capa. Cada imagen es un conjunto de capas que contienen los diferentes cambios que se van realizando sobre el sistema de archivos empaquetados. Al final del <code>dockerfile</code>, la \u00faltima instrucci\u00f3n define el comando que se ejecutar\u00e1 cuando arranquemos el contenedor. Al ejecutar un comando a partir de la imagen creada, se ejecuta el comando especificado y se convierte en el proceso con PID 1 dentro del \u00e1rbol virtual de procesos. El contenedor seguir\u00e1 en marcha mientras el proceso creado siga en ejecuci\u00f3n.</p>"},{"location":"docs/03_virtualizacion/","title":"Arranque de un Sistema Operativo","text":"<p>Ya hemos visto anteriormente que el hardware, por si solo es totalmente incapaz de realizar ninguna acci\u00f3n, necesita un software que le indique que tiene que hacer. Cuando encendemos un sistema inform\u00e1tico, estamos poniendo en marcha hardware, por lo que necesitan medios especiales para hacer que se cargue un primer software.</p>"},{"location":"docs/03_virtualizacion/#arranque-inicial-post","title":"Arranque Inicial POST","text":"<p>En los ordenadores compatibles actuales el proceso de carga de un sistema operativo cualquiera se compone de una serie de pasos que se inician cuando se enciende o reinicia el ordenador. El proceso comienza siempre en la BIOS, y salvando algunas peque\u00f1as variaciones que puede haber en funci\u00f3n de cada fabricante de hardware y del propio BIOS, el desarrollo paso a paso de esta secuencia es el siguiente:</p> <ul> <li>Cuando se da tensi\u00f3n a la fuente de alimentaci\u00f3n y una vez que la alimentaci\u00f3n se estabiliza, genera una se\u00f1al denominada \u201cPower Good\u201d en uno de los cables que va de la fuente de alimentaci\u00f3n a la placa base; esta se\u00f1al es recibida en el  juego de chips instalado en la referida placa, y a su vez genera una se\u00f1al  de reinicio (reset) al procesador.</li> </ul> <p></p> <ul> <li>La finalidad de este proceso es evitar que  el  procesador  arranque  prematuramente,  cuando  las  tensiones  de  alimentaci\u00f3n no son todav\u00eda correctas, lo que podr\u00eda producir da\u00f1os en el  hardware. Es el mismo sistema que se utiliza para un reinicio en caliente  cuando pulsa en el bot\u00f3n marcado \u201cReset\u201d.</li> </ul> <p></p> <ul> <li> <p>El procesador arranca cuando se retira la se\u00f1al de reset. En este momento  no existe en su memoria ninguna instrucci\u00f3n o dato, por lo que puede hacer absolutamente nada. Para salvar este obst\u00e1culo, los fabricantes incluyen en la circuir\u00eda (hardware) de la placa base un mecanismo especial. El sistema se dirige a una direcci\u00f3n fija de memoria (la FFFF0h en concreto). Esta direcci\u00f3n, situada muy cerca del final de la memoria del sistema en los primeros ordenadores compatibles, es el punto de inicio de la BIOS. En realidad, este punto de inicio contiene una instrucci\u00f3n de salto (jump) que indica al procesador donde tiene que dirigirse para encontrar el punto donde comienza realmente el programa de carga (BOOTSTRAP) de la BIOS. Este programa contenido en esa direcci\u00f3n se lleva a la CPU y se ejecuta.</p> </li> <li> <p>La primera parte de este programa de la BIOS inicia un proceso de comprobaci\u00f3n del hardware denominado POST (Power On Self Test), en caso de existir errores graves, el programa se detiene emitiendo  una  serie  de  pitidos  (http://www.bioscentral.com)  que  indican  el  tipo  de  error encontrado.  El  orden  de  las  comprobaciones  del  POST  depende  del  fabricante,  pero generalmente la secuencia de comprobaciones se resume como sigue:  </p> </li> <li>Comprobaci\u00f3n del procesador  </li> <li>Varias comprobaciones sobre la memoria  </li> <li>Inicializar los dispositivos de video y teclado. La comprobaci\u00f3n del dispositivo de video incluye cargar y ejecuta la parte de BIOS incluida en el adaptador de video. La mayor\u00eda de las adaptadoras modernas muestran en pantalla informaci\u00f3n sobre si mismas; es por esta raz\u00f3n por  la  que,  a  veces,  lo  primero  que  se  ve  en  pantalla  es  informaci\u00f3n  sobre  la  propia controladora de video antes que ning\u00fan mensaje de la BIOS del sistema.</li> <li>Determinar el tama\u00f1o de la RAM completa y comprobar su funcionamiento (el recuento que se ve en pantalla). Si llegado a este punto existiera alg\u00fan error en la memoria se mostrar\u00eda un mensaje de error (el dispositivo de video ya est\u00e1 operativo, as\u00ed que no hace falta emitir pitidos).</li> </ul> <p>   - Inicializar los puertos: COM (comunicaciones serie, LPT (comunicaci\u00f3n paralela), USB, S-ATA, SCSI, etc.   - Inicializar, en su caso, el sistema de disquete.   - Inicializar el sistema IDE, S-ATAo SCSI. (Discos duros, CDROMS, etc)   - A continuaci\u00f3n, el BIOS recorre la memoria en busca de la posible existencia de otros programas en ROM para ver si alguno tiene BIOS, lo que ocurre, por ejemplo, con los controladores de disco duro IDE/ATA, cuyos BIOS se encuentran en la direcci\u00f3n C8000h; otros elementos que suelen contar con sus propios BIOS son las tarjetas de red y las controladoras SCSI. Estos m\u00f3dulos son cargados y ejecutado.   - A  continuaci\u00f3n,  el  BIOS  muestra  su  pantalla  principal  (generalmente  con  los  cr\u00e9ditos  del fabricante  n\u00famero  de  versi\u00f3n  y  fecha).  Como  hemos  visto,  el  bios  realiza  una  especie  de inventario del sistema y algunas pruebas para verificar que su funcionamiento es correcto, y en esta pantalla muestra un resumen de  los  mismos.  En  los PC  originales  la  configuraci\u00f3n  del hardware  disponible  se  efectuaba mediante interruptores (\u201cJumpers\u201d) situados en la placa-base. Hoy en d\u00eda se utiliza el est\u00e1ndar PnP (Plug &amp; Play), que es capaz por s\u00ed misma de detectar y configurar los dispositivos conectados, asign\u00e1ndoles  los  recursos  necesarios  y  mostrando  un  mensaje  en  pantalla  por  cada  uno instalado.</p> <p></p> <p>La \u00faltima instrucci\u00f3n del programa POST se encarga de buscar otro programa que pueda ser cargado en  el  procesador  de  PC  para  que  se  encargue  de  seguir  arrancando  el  sistema  inform\u00e1tico, normalmente cargando ya un sistema operativo. </p> <p>\u00bfPero d\u00f3nde buscar\u00e1 el POST el programa a cargar? Y en caso de que existan varios sistemas operativos en varios soportes, \u00bfcu\u00e1l de ellos ser\u00e1 el elegido?</p>"},{"location":"docs/03_virtualizacion/#eleccion-y-arranque-de-un-sistema-operativo","title":"Elecci\u00f3n y arranque de un sistema operativo","text":"<p>En este punto en el que estamos el programa que est\u00e1 en la CPU es el POST, y ya ha concluido todo su trabajo. Pero si dicho programa simplemente liberar\u00e1 la CPU, el equipo se quedar\u00eda colgado ya que ning\u00fan otro software entrar\u00eda en el microprocesador. Por ello, la \u00faltima misi\u00f3n del POST es buscar otro programa, y cargarlo en la CPU antes de liberarla.   </p> <p>En  un  sistema  inform\u00e1tico  actual  podemos  tener m\u00faltiples  discos  duros,  cada  uno  de  ellos  con varias particiones donde pueden estar almacenados varios sistemas operativos, podemos tener un CD en la unidad lectora que tambi\u00e9n cuente con su propio sistema operativo, podemos tener un disquete de inicio en la disquetera, podemos tener un peque\u00f1o sistema operativo en un dispositivo USB, podemos tener un disco duro externo conectado por FireWire; etc. \u00bfC\u00f3mo puede saber el POST a cu\u00e1l de todos estos programas cederle el control?   </p> <p></p> <p></p> <p>De momento, en la BIOS de casi todos los equipos modernos es posible encontrar unas opciones que indican cual es el soporte de informaci\u00f3n desde el cual se va a arrancar el sistema (Boot). </p> <p>Normalmente estas opciones se encuentran en la segunda opci\u00f3n que aparece en el men\u00fa de la BIOS (opciones avanzadas de la BIOS o Advanced BIOS Features).   </p> <p>En alguna opci\u00f3n de este men\u00fa, normalmente se nos permite indicar varios dispositivos ordenados que utilizaremos para el arranque. Una opci\u00f3n que se puede dejar por defecto es indicar que se arranque desde el Floppy si existe, luego desde el CD, y por fin del HDD, para que nos permita arrancar el sistema desde disquete, si no existe desde CD, y si tampoco hay ning\u00fan CD de arranque, desde el disco duro. En las BIOS m\u00e1s modernas, veremos que tambi\u00e9n podemos indicarle que arranque desde un puerto USB, desde un puerto SATA, etc. </p> <p>Si  el  sistema  operativo  se  ejecuta desde disquete o CD, no  hay  demasiados  problemas,  dado que en un disquete o en un  CD solo puede haber un \u00fanico  proceso  de  arranque  para  un  \u00fanico sistema operativo.    </p> <p>Sin embargo, es posible que en disco duro tengamos varios sistemas operativos para arrancar en nuestra maquina en varias particiones. Adem\u00e1s, podemos tener varios discos duros en nuestro sistema, y en cada disco podemos tener varios sistemas operativos instalados. </p> <p>Desde  la  BIOS  vemos  c\u00f3mo  podemos  indicar  de  qu\u00e9  dispositivo  queremos  arrancar.  Podemos  indicar normalmente si queremos arrancar desde el disco duro, desde el CD, USB, etc. </p> <p>Hay BIOS desde donde se puede indicar incluso desde cu\u00e1l de los discos duros queremos arrancar (HDD-0, HDD-1, etc.) Hay que tener en cuenta que en algunas BIOS esta facilidad para distinguir entre los distintos discos  duros  no  est\u00e1  presente,  o  no  funciona  bien.  En  los  casos  en  que  esto  ocurra,  tendremos  que introducirnos en la BIOS y desactivar los discos duros de los que no queremos que arranque. As\u00ed, por ejemplo, en un sistema inform\u00e1tico de dos discos duros si queremos arrancar desde el primer disco duro no tenemos que hacer nada, pero si queremos arrancar desde el segundo disco duro desactivaremos el primero en la BIOS.   </p> <p></p> <p>Para desactivar los discos duros, hay que entrar en la primera opci\u00f3n de la BIOS y poner None, not instaled, o algo parecido en el tipo de disco duro que queremos desactivar. Esto no quiere decir que dichos discos duros no se usar\u00e1n durante el funcionamiento normal de la m\u00e1quina, sino que no se usar\u00e1n en el proceso de arranque.   Pero con esto conseguimos indicar al sistema inform\u00e1tico que disco duro quiero utilizar para el arranque del sistema... pero resulta que en un solo disco duro puedo tener instalado m\u00e1s de un sistema operativo.   </p> <p>\u00bfC\u00f3mo se le indica al sistema que quiero arrancar con Windows XP, o con Linux, o con Beos si todos estos SO est\u00e1n instalados en el mismo disco duro?   </p> <p></p> <p>Para entender esto tenemos que comprender bien como est\u00e1 organizado un disco duro. </p>"},{"location":"docs/03_virtualizacion/#organizacion-logica-del-disco-duro","title":"Organizaci\u00f3n l\u00f3gica del disco duro.","text":"<p>Vamos a ver c\u00f3mo se organiza un disco duro a alto nivel. En el m\u00f3dulo Fundamentos de Hardware tema 2 ya hemos visto c\u00f3mo se organiza a bajo nivel un disco duro y hemos visto como un disco duro se divide en particiones, los conceptos all\u00ed explicados nos ser\u00e1n \u00fatiles para entender este tema. </p> <p>Las  particiones  son  divisiones  l\u00f3gicas  efectuadas  en  un  disco  duro.  Responden  a  una  necesidad  muy importante en inform\u00e1tica: compartir un mismo disco duro para  varios  sistemas  operativos.  Cada  partici\u00f3n  tiene  la estructura l\u00f3gica correspondiente a su sistema operativo. Una partici\u00f3n Windows 98 contiene sector de arranque, FAT, directorio ra\u00edz y \u00e1rea de datos, una partici\u00f3n de Windows en NTFS tiene su sector de arranque y MFT, etc. Los datos de una partici\u00f3n no se mezclan con los de otra.   </p> <p>En un disco duro podemos tener hasta 4 particiones como m\u00e1ximo. De las 4, solo una puede estar definida como activa al mismo tiempo. Esta partici\u00f3n activa ser\u00e1 la que cargue el sistema operativo cuando iniciamos el sistema inform\u00e1tico.   </p> <p>El primer sector de cada una de estas particiones se conoce como sector de arranque, y en dicho sector (512 bytes) se almacena un programa especial que es el encargado de arrancar el sistema operativo de dicha partici\u00f3n.   </p> <p>En el primer sector del disco duro no se sit\u00faa un sector de arranque, en su lugar se sit\u00faa una tabla de particiones (Master Boot Record o MBR). Esta tabla de particiones incluye una tabla donde definimos las 4 particiones que pueden estar presentes en nuestro disco duro y su tama\u00f1o y un peque\u00f1o programa que permite localizar la partici\u00f3n activa, leer su sector de arranque y usarlo para arrancar nuestro sistema inform\u00e1tico.   </p> <p>Este MBR (Master Boot Record) est\u00e1 situado en el primer sector del disco duro, de modo que su tama\u00f1o es de 512 bytes. En esta capacidad se almacena lo siguiente por cada MBR:   </p> direccion contenido tipo +000h Programa MBR 445 Bytes +1BEh 1\u00ba entrada de la tabla de particiones 16 Bytes +1CEh 2\u00ba entrada de la tabla de particiones 16 Bytes +1DEh 3\u00ba entrada de la tabla de particiones 16 Bytes +1EEh 4\u00ba entrada de la tabla de particiones 16 Bytes +1FEh Identificaci\u00f3n (AA55h) 2 Bytes Contenido del Master Boot Record o MBR. <p>Longitud = 200h = 512 Bytes. </p> <p>El c\u00f3digo AA55h marca este sector como ejecutable.  </p> <p>Vemos como existe un programa al principio conocido como programa MBR que ocupa 445 Bytes.   </p> <p>Un programa MBR est\u00e1ndar leer\u00e1 la tabla de particiones y escoger\u00e1 de cu\u00e1l de esas particiones va a arrancar el sistema operativo. No lo har\u00e1 como podr\u00eda parecer l\u00f3gico de la primera partici\u00f3n, sino de la partici\u00f3n primaria que est\u00e1 marcada como activa. El MBR lee el primer sector de esa partici\u00f3n, y le cede el control de la CPU a ese programa (Boot Sector o Sector de Arranque).   </p> <p>Hay que indicar que no existe un programa MBR est\u00e1ndar. En realidad, el c\u00f3digo que se encuentra aqu\u00ed puede ser muy variado, aunque normalmente todos son compatibles. Podemos instalar programas MBR conocidos como gestores de arranque que ampl\u00edan las posibilidades el gestor de arranque MBR instalado por defecto.   </p> <p>Hay que prestar atenci\u00f3n a lo que se ha dicho. Si se arranca desde un disco duro, se lee el primer sector (MBR) y este a su vez, lee un segundo sector (Boot Sector). Vemos tambi\u00e9n como existen 4 entradas para almacenar hasta 4 particiones, de aqu\u00ed viene el l\u00edmite de 4 particiones para un disco duro.  Tambi\u00e9n vemos como por cada partici\u00f3n se almacena su tipo con 16 bytes. En estos 16 bytes se almacena lo siguiente:   </p> Direcci\u00f3n Contenido tipo +00h Estado de la partici\u00f3n: 00h \u2013 Inactiva  80h arranque (activa) 1 Byte +01h Cabeza de lectura / escritura donde comienza la partici\u00f3n. 1 Byte +02h Sector y cilindro donde comienza la partici\u00f3n. 2 Byte +04h <p>Tipo de partici\u00f3n: </p><p>00h \u2013 Libre   </p><p>01h \u2013 DOS con la vieja FAT de 12 bits. 02h \u2013 XENIX </p><p>03h \u2013 XENIX </p><p>04h \u2013 DOS con FAT 16   </p><p>05h \u2013 Partici\u00f3n extendida. </p><p>06h \u2013 Partici\u00f3n DOS &gt; 32 Megas. 0Bh \u2013 Windows FAT32 0Ch \u2013 Windows FAT 32 LBA 0Eh \u2013 VFAT </p><p>16h \u2013 Hidden FAT 16 (Oculta) 63h \u2013 Unix </p><p>65h \u2013 Novell Netware </p><p>Etc..... </p> 1 Byte +05h Cabeza de lectura / escritura donde termina la partici\u00f3n. 1 Byte +06h Sector y cilindro donde termina la partici\u00f3n. 2 Bytes +08h Direcci\u00f3n del primer sector de la partici\u00f3n. (Sector de arranque). 4 Bytes +0Ch N\u00famero de sectores en esta partici\u00f3n. 4 Bytes Contenido de cada una de las 4 entradas de la tabla de particiones. Longitud = 10h = 16 Bytes. <p>Vemos como el 1\u00ba campo se usa para indicar si esta partici\u00f3n es la activa o no. El 2\u00ba y 3\u00ba campo se usa para indicar el cilindro, sector y cabeza donde comienza la partici\u00f3n.   </p> <p>El 4\u00ba campo se usa para almacenar el tipo de la partici\u00f3n, aqu\u00ed se indica que sistema operativo est\u00e1 instalado en la partici\u00f3n, si dicha partici\u00f3n esta oculta o no, etc.  El 5\u00ba y 6\u00ba campo se usa para indicar el cilindro, sector y cabeza donde termina la partici\u00f3n.   </p> <p>El 7\u00ba campo indica la direcci\u00f3n del primer sector de la partici\u00f3n (el sector de arranque) para que el POST pueda pasarle el control. Este sector siempre es el 1o sector de la partici\u00f3n, pero aqu\u00ed indicamos su valor director (no de sector) y no la combinaci\u00f3n cilindro, sector y cabeza. Esto se hace para que el acceso al sector de arranque sea m\u00e1s r\u00e1pido, y para evitar posibles errores en la carga del sistema.   </p> <p>El 8\u00ba campo se usa para almacenar el n\u00famero total de sectores que existen en la partici\u00f3n. Es un campo que se usa para comprobar que los datos de la partici\u00f3n son correctos.  </p> <p>Las particiones de un disco duro pueden ser de dos tipos:   </p> <ul> <li>Primarias </li> <li>Extendidas   </li> </ul> <p>Como ya vimos anteriormente, en un disco duro puede existir un m\u00e1ximo de 4 particiones, sin embargo, s\u00f3lo una de estas particiones puede ser extendida. (Si seguimos las recomendaciones del est\u00e1ndar usado para organizar l\u00f3gicamente los discos duros).   </p> <p>Cada partici\u00f3n primaria forma su propio volumen de datos (la letra en Windows, para entendernos) y tiene su propio sector de arranque. Son las particiones normales.   </p> <p>Una partici\u00f3n extendida, sin embargo, no forma ning\u00fan volumen, ni tiene un sector de arranque como tal. Una partici\u00f3n extendida en realidad es un contenedor de unidades l\u00f3gicas. Se pueden crear tantas unidades l\u00f3gicas  en  una  partici\u00f3n  extendida  como  se  deseen.  A  t\u00e9rminos  pr\u00e1cticos,  estas  unidades  l\u00f3gicas  se comportan como particiones primarias.   </p> <p>Cada unidad l\u00f3gica que se crea dentro de una unidad extendida forma su propio volumen, aunque no tiene un sector de arranque real, sino que usa su sector de arranque para controlar su tama\u00f1o entre otras cosas.   </p> <p>De esta manera, si dividimos un disco duro en una partici\u00f3n primaria (un volumen) y una partici\u00f3n extendida (donde creamos 10 unidades l\u00f3gicas, cada una con su propio volumen) formaremos un total de 11 vol\u00famenes (11 letras de unidad) pero solo tendremos un sector de arranque usable como tal, el de la partici\u00f3n primaria. </p> <p>Solo el sector de arranque de una partici\u00f3n primaria es v\u00e1lido para arrancar el sistema operativo. El sector de  arranque  de  la  partici\u00f3n  extendida  solo  contiene  informaci\u00f3n  sobre  las  unidades  l\u00f3gicas  que  se encuentran dentro de ella (tama\u00f1os, comienzos y finales, etc.). </p> <p>La tabla del MBR identifica la localizaci\u00f3n y tama\u00f1o de la partici\u00f3n extendida, pero no contiene informaci\u00f3n sobre las unidades l\u00f3gicas creadas dentro de esta partici\u00f3n extendida. Ninguna de estas unidades l\u00f3gicas puede ser marcadas como activas, por lo que es posible que instalemos un sistema operativo en alguna de estas particiones l\u00f3gicas, pero nunca podr\u00e1 ser cargado directamente, ya que no podemos marcar esa partici\u00f3n como activa, y por lo tanto no podemos indicar que sea el volumen de arranque. (Para poder instalar sistemas operativos en estas unidades l\u00f3gicas, tendremos que usar un programa conocido como gestor de arranque que veremos posteriormente, estos gestores de arranque suelen guardar los programas usados para cargar los sistemas operativos siempre en la partici\u00f3n activa del disco duro).   </p> <p>Hemos visto como el MBR se divide en dos partes bien diferenciadas, el programa MBR que ocupa la mayor parte del MBR y la tabla de particiones vista anteriormente.   </p>"},{"location":"docs/03_virtualizacion/#gpt","title":"GPT","text":"<p>Hemos visto en el punto anterior como funciona un disco duro con una tabla de particiones MBR, que es la opci\u00f3n  m\u00e1s  habitual  con  la  que  nos  vamos  a  encontrar.  Sin  embargo,  desde  hace  un  tiempo  se  est\u00e1 substituyendo nuestras antiguas BIOS por un sistema m\u00e1s moderno conocido como EFI (Extensive Firmware Interface).   </p> <p>Este sistema, totalmente incompatible con BIOS, permite que en el disco duro nos olvidemos si queremos de la MBR y utilicemos un sistema mucho m\u00e1s potente, conocido como GPT (GUID Partition Table, siendo GUID acr\u00f3nimo de Globally Unique Identifiers).   </p> <p>GPT usa un moderno modo de direccionamiento l\u00f3gico (LBA, logical block addressing) en lugar del modelo cilindro-cabeza-sector (CHS) usado con el MBR. La informaci\u00f3n de MBR heredado est\u00e1 almacenada en el LBA 0 o bloque l\u00f3gico 0, la cabecera GPT est\u00e1 en el LBA 1, y la tabla de particiones en s\u00ed en los bloques sucesivos. En los sistemas operativos Windows de 64-bits, 16.384 bytes, o lo que es lo mismo, 32 sectores, est\u00e1n reservados para la GPT, dejando el bloque LBA 34 como el primer sector usable del disco.   </p> <p>GPT proporciona asimismo redundancia. La cabecera GPT y la tabla de particiones est\u00e1n escritas tanto al principio como al final del disco.   </p> <p></p> <p>Vemos como al principio del disco se guarda un sector conocido como protective MBR. El prop\u00f3sito de este sector es permitir que programas y sistemas que est\u00e1n preparados solo para trabajar con MBR y no con GPT puedan ver el disco como v\u00e1lido.   </p> <p>Este MBR \u201cfalso\u201d est\u00e1 configurado con una sola partici\u00f3n que ocupa todo el disco, y es totalmente obviado por EFI, por lo que no se utiliza nunca. Sin embargo, si un programa o sistema operativo antiguo intenta usar este disco, creer\u00e1 que el disco duro es un MBR normal de 1 sola partici\u00f3n, y cuando intente acceder al disco duro, se dar\u00e1 cuenta que la informaci\u00f3n almacenada en el no coincide con lo que \u00e9l espera, y mostrar\u00e1 un mensaje indicando que la estructura del disco duro esta corrompida, que no encuentra el sistema, o algo parecido.   </p> <p>Es este el gran fallo de GPT, que solo es compatible con los nuevos sistemas operativos y los nuevos programas. Por poner un ejemplo, si instalamos Windows 7 64 bits configurando el disco como GPT, si luego queremos instalar un sistema operativo anterior en ese mismo disco duro, el propio sistema nos indicar\u00e1 en la instalaci\u00f3n que no puede trabajar con el disco duro ya que esta corrompido, y no podremos instalar el sistema.   </p> <p>Por ejemplo, todas las versiones de Windows 7 pueden leer discos GPT, pero solo las versiones de 64 bits de Windows 7 pueden arrancar desde un disco duro GPT.   </p> <p>La cabecera de la tabla de particiones (Primary GPT Header) define los bloques de disco que pueden ser utilizados por el usuario (bloques usables). Tambi\u00e9n define el n\u00famero y tama\u00f1o de las entradas de partici\u00f3n que conforman la tabla de particiones. En Windows hay 128 entradas de partici\u00f3n reservadas, cada una de 128 bytes de longitud. As\u00ed, se pueden crear hasta 128 particiones si usamos un sistema tipo Windows.   </p> <p>La cabecera contiene el GUID del disco (Globally Unique Identifier, Identificador Global \u00danico). Registra su propio tama\u00f1o y localizaci\u00f3n (siempre LBA 1), y el tama\u00f1o y la localizaci\u00f3n de la cabecera y tabla de la GPT secundarias (siempre en el \u00faltimo sector del disco). Contiene una suma de comprobaci\u00f3n CRC32 para s\u00ed mismo y para la tabla de partici\u00f3n, que se verifica por los procesos EFI durante el arranque. Adem\u00e1s, todo GPT est\u00e1 configurado para usar Unicode.   </p> <p>Para entender mejor por qu\u00e9 se crea GPT, veamos los principales problemas que presentan MBR y las ventajas que aporta GPT.   </p>"},{"location":"docs/03_virtualizacion/#problemas-con-el-mbr","title":"Problemas con el MBR","text":"<ol> <li>En MBR s\u00f3lo pueden ser definidas 4 particiones primarias o 3 primarias + 1 partici\u00f3n extendida (con un n\u00famero arbitrario de particiones l\u00f3gicas dentro de la partici\u00f3n extendida).  </li> <li>En MBR dentro de la partici\u00f3n extendida, los metadatos de las particiones l\u00f3gicas se almacenan en una estructura de lista enlazada. Si un enlace se pierde, todas las particiones l\u00f3gicas existentes, despu\u00e9s de los metadatos, se pierden.  </li> <li>MBR s\u00f3lo admite 1 byte para c\u00f3digos de tipo de partici\u00f3n, lo que conlleva muchas colisiones.  </li> <li>MBR almacena la informaci\u00f3n del sector de la partici\u00f3n con valores LBA de 32 bits. Esta longitud de LBA junto con los 512 byte del tama\u00f1o del sector (m\u00e1s com\u00fanmente utilizados) limita el tama\u00f1o m\u00e1ximo manejable del disco hasta 2  </li> </ol>"},{"location":"docs/03_virtualizacion/#ventajas-de-gpt","title":"Ventajas de GPT","text":"<ol> <li>Utiliza GUID (UUID) para identificar los tipos de particiones. Sin colisiones.  </li> <li>Proporciona un GUID \u00fanico de disco y un GUID \u00fanico de partici\u00f3n para cada partici\u00f3n. Un buen sistema de archivos independiente referenciando a las particiones y discos.   </li> <li>N\u00famero arbitrario de particiones (depende del espacio asignado por la tabla de particiones). No hay necesidad de particiones extendidas y l\u00f3gicas. Por defecto, la tabla GPT contiene espacio para la definici\u00f3n de 128 particiones. Sin embargo, si el usuario desea definir m\u00e1s particiones, se puede asignar m\u00e1s espacio (de momento solo en Linux).   </li> <li>Utiliza 64-bit LBA para almacenar n\u00fameros del Sector - tama\u00f1o m\u00e1ximo del disco manejable es de 2 Zeta Bytes.   </li> <li>Almacena una copia de seguridad del encabezado y de la tabla de particiones al final del disco que ayuda en la recuperaci\u00f3n en el caso de que los primeros est\u00e1n da\u00f1ados.   </li> <li>C\u00f3digo de reparaci\u00f3n de errores CRC32 para detectar errores y da\u00f1os de la cabecera y en la tabla de particiones. </li> </ol>"},{"location":"docs/03_virtualizacion/#comandos-para-comprobar-particiones-del-disco-y-administrador-de-discos-de-windows","title":"Comandos para comprobar particiones del disco y administrador de discos de Windows","text":""},{"location":"docs/03_virtualizacion/#diskpart","title":"Diskpart","text":"<p>En esta ocasi\u00f3n vamos a estudiar los comandos b\u00e1sicos para ver las particiones creadas en los discos duros de nuestro equipo, tanto internos como unidades extra\u00edbles. Para conocer estos comandos, se adjunta un enlace a una p\u00e1gina web con la explicaci\u00f3n sobre la herramienta  \u201cdiskpart\u201d, disponible en Windows:</p> <p>Acceder a gu\u00eda de uso de diskpart desde el cmd</p> <p>Es muy importante que abr\u00e1is la ventana de comandos (cmd) como administrador.</p> <p>Si quieres ver el uso de esta herramienta, puedes tambi\u00e9n ver el siguiente v\u00eddeo tutorial que elabor\u00f3 el  profesor Jose Antonio pasado:</p> <p>V\u00eddeo del uso de diskpart en Windows </p> <p>Os aconsejo que intent\u00e9is los comandos mientras veis el v\u00eddeo, ya que en breve ser\u00e1 tu turno.  </p>"},{"location":"docs/03_virtualizacion/#administrador-de-discos","title":"Administrador de discos","text":"<p>Existe una herramienta alternativa gr\u00e1fica, que nos proporciona Windows 7 y versiones posteriores que se llama administrador de discos.  Con esta herramienta podemos ver, de forma gr\u00e1fica, toda la informaci\u00f3n de los diferentes discos duros del equipo.  </p> <p>Para acceder a esta herramienta tenemos varias opciones: - Bot\u00f3n derecho sobre el icono de Inicio, seleccionamos \u201cAdministraci\u00f3n de discos\u201d en el men\u00fa emergente. - Escribir \u201cadministraci\u00f3n de discos\u201d en el buscador de Windows y pulsamos en la opci\u00f3n encontrada. - Pulsar en el teclado la combinaci\u00f3n de teclas <code>Windows + R</code>. En el men\u00fa ejecutar escribimos <code>diskmgmt.msc</code>.</p>"},{"location":"docs/03_virtualizacion/#arranque-de-windows","title":"Arranque de Windows","text":""},{"location":"docs/03_virtualizacion/#arranque-de-windows-7vista2008810","title":"Arranque de Windows 7/Vista/2008/8/10","text":"<p>La secuencia de arranque de Windows cambi\u00f3 a partir de XP. La principal diferencia estriba en que se ha cambiado el gestor de arranque, ya no se usa el <code>ntldr</code>, sino que se usa el Windows Boot Manager (<code>bootmgr</code>).   </p> <p>Mientras que el gestor <code>ntldr</code> usaba un fichero de texto denominado <code>boot.ini</code> para configurar sus opciones, <code>bootmgr</code> utiliza una base de datos conocida como Boot Configuration Data (BCD) que no puede ser editada directamente como lo era el <code>boot.ini</code> ya que no es un fichero de texto.   </p> <p>El BCD es una base de datos con datos sobre la configuraci\u00f3n del arranque que se suele almacenar en \\Boot\\Bcd.   </p> <ol> <li>Se carga y ejecuta el POST</li> <li>Se carga el MBR del disco duro (si es la opci\u00f3n elegida en la BIOS)  </li> <li>Se carga el sector de arranque de la partici\u00f3n primaria activa   </li> <li>Se carga el programa <code>bootmgr</code> </li> <li><code>bootmgr</code> ajusta el procesador para trabajar a 32 bits o 64 bits.   </li> <li><code>bootmgr</code> lee la base de datos BCD y muestra un men\u00fa si es necesario   </li> <li>El usuario selecciona un sistema operativo del men\u00fa, o se carga por defecto uno de ellos </li> <li><code>bootmgr</code> carga <code>winload.exe</code></li> <li><code>winload.exe</code> carga <code>NTOSKRNL.EXE</code> (N\u00facleo del sistema operativo o Kernel).</li> <li><code>NTOSKRNL.EXE</code> lee el registro de Windows, y procede a ir cargando el sistema completo.  </li> </ol> <p>Windows dispone de un comando para configurar esta base de datos BCD, el <code>bcedit.exe</code>, pero es realmente engorroso de usar. Es mejor usar una utilidad grafica de una 3rd party (tercera compa\u00f1\u00eda, una compa\u00f1\u00eda distinta a la que realiza el sistema) como puede ser <code>EasyBCD</code> que permite configurar muchas m\u00e1s opciones que el <code>bcedit.exe</code> y de forma mucho m\u00e1s f\u00e1cil.</p>"},{"location":"docs/03_virtualizacion/#novedades-en-windows-8-10","title":"Novedades en Windows 8 / 10","text":"<p>Aunque el arranque de Windows actual es muy similar al de Windows 7 incorpora varias novedades, muchas de ellas basadas en el uso de UEFI en lugar de BIOS. Una de las m\u00e1s importantes es la del Secure Boot. </p>"},{"location":"docs/03_virtualizacion/#secure-boot","title":"SECURE BOOT","text":"<p>Los ordenadores cuando encontraban el sector de arranque del SO que quer\u00edan cargar, se limitaban a ejecutar dicho c\u00f3digo, sin comprobar de ning\u00fan modo qu\u00e9 es lo que se est\u00e1 ejecutando.   </p> <p>Sin embargo, si contamos en el sistema con UEFI en lugar de BIOS y esta activada una caracter\u00edstica conocida como  Secure  Boot,  el  firmware  del  sistema  comprueba  la  firma  digital  del  sector  de  arranque,  para comprobar si es de un sistema reconocido, y si se ha producido alg\u00fan tipo de modificaci\u00f3n sobre el mismo. Para permitir el arranque del sistema operativo, se deben dar una de las siguientes situaciones:   </p> <ul> <li>El c\u00f3digo de carga fue firmado utilizando un certificado \u201cde confianza\u201d. Por ejemplo, un certificado de Microsoft. </li> <li>El usuario ha aprobado la firma digital del c\u00f3digo de carga. UEFI deber\u00eda permitir al usuario realizar esta acci\u00f3n. (No siempre ocurre).  </li> <li>El usuario deshabilita Secure Boot en la configuraci\u00f3n de UEFI.  </li> <li>El usuario deshabilita totalmente UEFI, y en su lugar utiliza BIOS.  </li> </ul>"},{"location":"docs/03_virtualizacion/#trusted-boot","title":"TRUSTED BOOT","text":"<p>Una vez que secure boot ha terminado su cometido, el c\u00f3digo de carga (bootloader) verifica el firmado del kernel de Windows 8 antes de cargarlo. A su vez, el kernel de W8 verifica todos los componentes de Windows que se van cargando, incluyendo los drivers de dispositivo de la propia Microsoft que se cargan en el arranque. Si un fichero ha sido modificado, el bootloader detecta el problema y se niega a seguir cargando el componente. Windows 8 intenta reparar el componente corrupto autom\u00e1ticamente.  </p>"},{"location":"docs/03_virtualizacion/#fast-startup","title":"FAST STARTUP","text":"<p>Windows Fast Startup (Inicio r\u00e1pido) es la opci\u00f3n por defecto a utilizar en Windows 8, Windows Server 2016 y Windows 10 siempre que se utilice UEFI.  </p> <p>En un sistema Windows en cada momento se encuentran ejecut\u00e1ndose dos sesiones en realidad, la del usuario actual y la del kernel del sistema. Cuando en Windows 7 se apaga el sistema, se cierran ambas sesiones y hay que volver a cargarlas desde cero cuando el sistema se inicia. </p>"},{"location":"docs/03_virtualizacion/#arranque-de-sistemas-linux","title":"Arranque de sistemas Linux","text":"<p>Este proceso de arranque comienza desde que el MBR o GPT, busca el sector de arranque de la partici\u00f3n en la que se encuentra el sistema operativo de Linux.   </p> <p>En las actuales distribuciones de Linux, cuando accedamos al sector de arranque nos encontraremos con un gestor de arranque llamado GRUB (Grand Unified Bootloader). Grub es un gestor de arranque m\u00faltiple, desarrollado bajo licencia GNU, que nos permite elegir el sistema operativo del que queremos arrancar. GRUB, no suele tener problemas de compatibilidad para permitir el arranque de cualquier sistema operativo, como los OS o Windows entre otros.  </p> <p>En este caso nos vamos a centrar en el arranque de un Sistema Linux basado en Debian, como Ubuntu. Partimos con la carga de GRUB del sector de arranque y seleccionando el Sistema Linux.  </p> <p>En este momento se entra en la fase del Kernel de Linux, que es cargado como un archivo comprimido de imagen de tipo zlib). Entonces se cargan los elementos hardware m\u00ednimos para poder continuar con su carga.   </p> <p>Mediante la funci\u00f3n startup del kernel, este se descomprime y se carga completamente en memoria, detecta el tipo de procesador y carga muchas funciones de inicializaci\u00f3n.  </p> <p>En la siguiente etapa, se ejecuta el proceso init cuya funci\u00f3n es conseguir que todo el sistema se cargue por completo. Se encarga del montaje del sistema de archivos, inicia los servicios de usuario necesarios y cambia al entorno de usuario cuando el proceso ha finalizado.   </p> <p>Ya estar\u00edamos ante la Shell para introducir nuestras credenciales.</p>"},{"location":"docs/03_virtualizacion/#modos-de-red-en-virtualbox","title":"Modos de Red en VirtualBox","text":"Modo red Direcci\u00f3n red Guest-Host Host-Guest MM.VV. Red local-Host Internet Descripci\u00f3n NAT 10.0.X.0/24 (X=2,3,4,5) S\u00ed No No No S\u00ed Cada invitado tiene su direcci\u00f3n propia y navega de forma aislada. Se comunica con el anfitri\u00f3n y con Internet mediante un router NAT virtual. Adaptador puente Red anfitri\u00f3n S\u00ed S\u00ed S\u00ed S\u00ed S\u00ed El invitado usa la tarjeta de red del anfitri\u00f3n usando un puente(Bridge). Red NAT Red virtual configurada S\u00ed No S\u00ed No S\u00ed Red virtual NAT en la que las MMVV de la misma red virtual pueden comunicarse.Tiene comunicaci\u00f3n al exterior con NAT. Red interna Configurar manualmente No No S\u00ed No No Las m\u00e1quinas virtuales forman una red interna entre ellas sin comunicaci\u00f3n al exterior. Deben configurarse las tarjetas de red manualmente. S\u00f3lo- anfitri\u00f3n Red desde Adaptador virtual S\u00ed No S\u00ed No No Es similar a la red interna pero permiten la comunicaci\u00f3n con el anfitri\u00f3n para aprovechar sus servicios. Funciona aunque no haya cable de red conectado. <p>Estas configuraciones son las mostradas en el caso en el que cada m\u00e1quina virtual monte una \u00fanica tarjeta de red, sin que haya otras tarjetas de red que puedan hacer de adaptador puente con otras redes. </p>"}]}